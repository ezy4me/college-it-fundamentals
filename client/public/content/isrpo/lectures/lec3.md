# Лекция №2. Работа с удалённым репозиторием. Ветвление

## 1. Удалённый репозиторий

> **Удалённый репозиторий** — копия проекта, хранящаяся на сервере (например, GitHub, GitLab, Bitbucket) и доступная по сети.

- Это полноценный репозиторий со своей историей, ветками и `HEAD`.  
- Подключение к удалённому репозиторию позволяет совместно работать над кодом, синхронизировать изменения между компьютерами и создавать резервные копии.

---

## 2. Подключение удалённого репозитория к локальному

> **Команда `git remote add`** — добавляет ссылку на удалённый репозиторий в локальный проект.

**Когда нужно:** когда у вас уже есть локальный репозиторий, и вы хотите связать его с сервером (например, для публикации кода).

**Формат команды**  
```bash
git remote add <имя> <URL-адрес>
```

**Назначение:** Добавляет ссылку на удалённый репозиторий под заданным именем (обычно `origin`).

**Пример**  
```bash
git remote add origin https://github.com/CIT2025/4335Group-26
```

**Как получить URL-адрес:**  
На GitHub на странице репозитория нажмите кнопку **Code**. Доступны варианты:  
1. **HTTPS:** `https://github.com/username/repo.git`  
2. **SSH:** `git@github.com:username/repo.git`  
3. **GitHub CLI:** `gh repo clone username/repo`

![Получение URL-адреса репозитория](https://cithub.ru/api/files/вомбат.jpg)

---

## 3. Отключение удалённого репозитория

> **Команда `git remote remove`** — удаляет связь с удалённым репозиторием из локальных настроек.

**Формат команды**  
```bash
git remote remove <имя>
```

**Назначение:** Удаляет запись об удалённом репозитории. **Не удаляет сам репозиторий на сервере.**

**Пример**  
```bash
git remote remove origin
```

--- 

## 4. Управление удалёнными репозиториями

### 4.1. Переименование удалённого репозитория

> **Команда `git remote rename`** — изменяет локальное имя подключённого удалённого репозитория.

**Формат команды**  
```bash
git remote rename <старое_имя> <новое_имя>
```

**Назначение:** Изменяет локальное имя для подключённого удалённого репозитория.

**Пример**  
```bash
git remote rename origin upstream
```

---

### 4.2. Просмотр удалённых репозиториев

> **Команда `git remote show`** — отображает список или подробную информацию об удалённых репозиториях.

**Формат команды**  
```bash
git remote show [имя_репозитория]
```

**Назначение:**  
- Без параметров — выводит список всех подключённых удалённых репозиториев.  
- С именем — показывает подробную информацию о конкретном репозитории.

**Примеры**  
```bash
# Список всех удалённых репозиториев
git remote show
# origin
# upstream

# Подробная информация о репозитории origin
git remote show origin
```

---

## 5. Клонирование удалённого репозитория

> **Команда `git clone`** — создаёт на компьютере полную локальную копию удалённого репозитория со всей историей, ветками и настройками.

**Формат команды**  
```bash
git clone <URL_репозитория>
```

**Назначение:** Скачивает удалённый репозиторий и автоматически настраивает связь с ним.

**Пример**  
```bash
git clone https://github.com/CIT2025/4335Group-26
```

**Что происходит при клонировании:**  
1. Создаётся папка с именем репозитория (например, `4335Group-26/`).  
2. Копируется весь репозиторий: все коммиты, ветки, файлы.  
3. Автоматически добавляется удалённый репозиторий под именем `origin`.  
4. Создаётся локальная ветка, соответствующая основной ветке удалённого репозитория (обычно `main` или `master`).

**Альтернатива (вручную):**  
```bash
git init
git remote add origin <URL>
git pull origin main
```

> **Вывод:** `git clone` — стандартный и самый удобный способ начать работу с существующим проектом.

--- 

## 6. Получение изменений из удалённого репозитория

> **Команда `git fetch`** — загружает изменения из удалённого репозитория в локальный, но **не вносит их в рабочий каталог**.

**Формат команды**  
```bash
git fetch [имя_репозитория]
```

**Ключи:**  
- `--all` — получает изменения из всех подключённых удалённых репозиториев.

**Пример**  
```bash
git fetch origin
```

### 6.1. Как работает `git fetch`

1. Скачивает новые коммиты из указанного удалённого репозитория.  
2. Обновляет удалённые ветки в локальном репозитории (например, `origin/develop`).  
3. **Не меняет** локальные ветки (`develop`, `main`) и рабочий каталог.

**Визуализация процесса:**

До `git fetch`:  
```
Локально:    develop → коммит A
Удалённо:    origin/develop → коммит B (новый коммит после A)
```

После `git fetch`:  
```
Локально:    develop → коммит A
             origin/develop → коммит B (обновлено)
```

> **Важно:** Файлы из новых коммитов сохраняются в `.git/objects/`, но не появляются в рабочей директории.

---

### 6.2. Как применить полученные изменения

После `git fetch` доступны следующие варианты:

1. **Слияние с локальной веткой (`git merge`):**  

```bash
git checkout develop
git merge origin/develop
```

2. **Переход на удалённую ветку (не рекомендуется для активной работы):**  

```bash
git checkout origin/develop  # состояние detached HEAD
```

3. **Использование `git pull`** — автоматически выполняет `fetch` + `merge` (рассматривается далее).

---

### 6.3. Пример полного цикла обновления

```bash
# 1. Получить изменения с сервера
git fetch origin

# 2. Перейти в свою ветку
git checkout develop

# 3. Объединить изменения
git merge origin/develop
```

> **Вывод:** `git fetch` — безопасный способ обновить информацию об удалённом репозитории без риска нарушить локальную работу. Позволяет сначала просмотреть изменения, а затем решить, как их интегрировать.

--- 

## 7. Получение изменений и обновление рабочей копии

> **Команда `git pull`** — объединяет две операции: `git fetch` (получение изменений) и `git merge` (слияние с текущей веткой), автоматически обновляя рабочую копию.

**Формат команды**  
```bash
git pull [имя_репозитория] [ветка]
```

**Ключи управления слиянием:**  
- `--ff` — разрешить fast-forward (по умолчанию)  
- `--no-ff` — всегда создавать merge-коммит  
- `--ff-only` — отменить операцию, если fast-forward невозможен

**Пример**  
```bash
git pull origin main
```

**Что происходит:**  
1. `git fetch origin` — загружает изменения из удалённого репозитория  
2. `git merge origin/main` — сливает изменения в текущую локальную ветку

> **Вывод:** `git pull` — стандартный способ быстро синхронизировать локальную ветку с удалённой.

---

## 8. Отправка изменений в удалённый репозиторий

> **Команда `git push`** — загружает локальные коммиты в удалённый репозиторий.

**Формат команды**  
```bash
git push [имя_репозитория] [ветка]
```

**Основные ключи:**  
- `-f` или `--force` — принудительная отправка (перезаписывает удалённую историю)  
- `--all` — отправить все локальные ветки  
- `--force-with-lease` — безопасный force: отменяет операцию, если кто-то уже обновил ветку

**Пример**  
```bash
git push origin develop
```

### 8.1. Три сценария выполнения `git push`

1. **Fast-forward возможно** (ваша ветка впереди удалённой)  

- Изменения успешно отправляются.

2. **Fast-forward невозможен** (удалённая ветка опережает вашу)  

- Ошибка: требуется сначала сделать `git pull`.

3. **Использован `--force`** 

- Локальная история перезаписывает удалённую (опасно!).

### 8.2. Рекомендации по использованию `git push`

- Перед `push` всегда делайте `pull`.  
- Используйте `--force-with-lease` вместо `--force` для безопасности.  
- Не используйте `--force` в общей ветке (`main`/`develop`).

**Пример безопасного workflow:**  
```bash
# 1. Получить свежие изменения
git pull origin main

# 2. Отправить свои изменения
git push origin main
```

--- 

## 9. Ветвление в Git

### 9.1. Определение ветки

> **Ветка в Git** — указатель на конкретный коммит; создание ветки означает создание нового указателя, который можно перемещать независимо от других.

**Логический уровень:** ветка — последовательность коммитов, представляющая независимую линию разработки.  
**Физический уровень:** ветка — файл в `.git/refs/heads/`, содержащий хеш последнего коммита.

**Примеры указателей:**  
- `HEAD` — указывает на текущую ветку или коммит (определяет рабочую копию)  
- `ORIG_HEAD` — хранит предыдущее положение `HEAD` (для отката)  
- `main` / `master` — основная ветка по умолчанию

---

### 9.2. Назначение веток

1. **Параллельная разработка** — несколько разработчиков работают над разными задачами одновременно.  
2. **Эксперименты** — тестирование новых функций без риска для основного кода.  
3. **Параллельные релизы** — поддержка разных версий продукта (например, Python 2.x и 3.x).

---

### 9.3. Создание и переключение веток

**Способ 1 (классический):**  
```bash
# Создать ветку
git branch feature

# Переключиться на ветку
git checkout feature
```

**Способ 2 (рекомендуемый):**  
```bash
# Создать и сразу переключиться
git checkout -b feature
```

**Что происходит внутри:**  
1. Создаётся файл `.git/refs/heads/feature`  
2. В него записывается хеш текущего коммита  
3. При переключении обновляется файл `.git/HEAD`

---

### 9.4. Просмотр веток

```bash
# Все локальные ветки (звёздочка = текущая)
git branch

# Только удалённые ветки
git branch -r

# Все ветки (локальные + удалённые)
git branch -a
```

---

### 9.5. Переключение между ветками

```bash
# Переключиться на ветку
git checkout develop

# Вернуться к предыдущей ветке
git checkout -
```

> **Важно:** Несохранённые изменения (не в коммите) перейдут с вами на другую ветку. Проверяйте `git status` перед переключением.

---

### 9.6. Просмотр истории ветки

```bash
# Базовая история
git log

# Последние 5 коммитов в одну строку
git log -5 --pretty=oneline

# История с визуализацией веток
git log --all --graph

# История конкретной ветки (от расхождения с develop до feature)
git log develop..feature --pretty=oneline

# Показывать изменения в каждом коммите
git log -p

# Только последние N коммитов
git log -3
```

---

### 9.7. Работа с файлами в ветках

```bash
# Проверить состояние файлов в текущей ветке
git status

# Если есть несохранённые изменения
git add .
git commit -m "Сообщение"
git checkout другая_ветка  # Теперь можно безопасно переключиться
```

> **Правило:** Перед переключением веток убедитесь, что `git status` показывает чистую рабочую копию (нет unstaged изменений).

---

### 9.8. Визуализация структуры веток

Наглядное представление помогает понять отношения между ветками:
```text
* b5d1548 (feature) adding new feature
| * a1b2c3d (main) update config
|/
* 62aa0f1 initial commit
```

Для получения такого вида используйте:
```bash
git log --all --graph --oneline
```

--- 

## 10. Сравнение изменений: команда `git diff`

> **Команда `git diff`** — показывает различия между файлами, коммитами, ветками или состоянием рабочего каталога и индекса.

**Формат команды**  
```bash
git diff [опции] [объект1] [объект2]
```

**Основные опции:**  
- `--diff-filter=<A|D|M>` — фильтрует по типу изменений:  
  - `A` — добавленные файлы  
  - `D` — удалённые файлы  
  - `M` — изменённые файлы  
- `--word-diff=color` — подсвечивает изменения по словам (зелёный = добавлено, красный = удалено)

### 10.1. Примеры использования

**1. Сравнение двух коммитов:**  
```bash
# Найти хеши коммитов
git log -2 --pretty=oneline

# Сравнить их (достаточно первых 5–7 символов)
git diff 89577ee f0c9083
```

**Пример вывода:**  
```diff
diff --git a/doc.txt b/doc.txt
index 683de51..33a584a 100644
--- a/doc.txt
+++ b/doc.txt
@@ -1,2 +1,2 @@
-Строка 1 (будет удалена)
+Строка 3 (заменила Строку 1)
 Строка 2 (не меняется)
```

**Расшифровка вывода:**  
- `--- a/doc.txt` — файл в первом коммите  
- `+++ b/doc.txt` — файл во втором коммите  
- `@@ -1,2 +1,2 @@` — блок изменений: удалено 2 строки, добавлено 2 строки  
- `-` — удалённая строка  
- `+` — добавленная строка

**2. Другие полезные варианты:**  
```bash
# Сравнить рабочий каталог и индекс
git diff

# Сравнить индекс и последний коммит
git diff --staged

# Сравнить текущую ветку с другой
git diff main..feature

# Показать только добавленные файлы между коммитами
git diff --diff-filter=A коммит1 коммит2
```

---

## 11. Удаление веток

> **Команда `git branch -d`** — безопасно удаляет ветку, только если она полностью слита.  
> **Команда `git branch -D`** — принудительно удаляет ветку в любом случае.

**Формат команды**  
```bash
git branch -d <имя_ветки>    # безопасное удаление
git branch -D <имя_ветки>    # принудительное удаление
```

**Разница между `-d` и `-D`:**  
- **`-d`** — удаляет только если ветка полностью слита с другой веткой  
- **`-D`** — удаляет в любом случае, даже с неслитыми изменениями

**Пример:**  
```bash
# Проверим ветки
git branch
# * develop
#   feature
#   main

# Попробуем безопасно удалить feature
git branch -d feature
# error: The branch 'feature' is not fully merged.

# Принудительное удаление
git branch -D feature
# Deleted branch feature (was cc8005b)
```

> **Важно:**  
> 1. Нельзя удалить текущую ветку (где находится `HEAD`).  
> 2. Перед удалением переключитесь на другую ветку.  
> 3. Неслитые изменения будут утеряны (но коммиты останутся в истории).

---

## 12. Практика: работа с ветками

**Задача:** Добавить два модуля в библиотеку `geometric_lib`.

**Решение:**  
```bash
# 1. Клонировать репозиторий
git clone https://github.com/smartiqaorg/geometric_lib

# 2. Создать и перейти на новую ветку
git checkout -b new_features

# 3. Добавить rectangle.py и сделать коммит
git add rectangle.py
git commit -m "L-03: Added rectangle.py"

# 4. Добавить triangle.py, исправить rectangle.py и сделать коммит
git add triangle.py rectangle.py
git commit -m "L-03: Added triangle.py and fixed rectangle perimeter bug"

# 5. Просмотреть историю
git log --all --pretty=oneline --graph

# 6. Сравнить два последних коммита
git diff <хеш1> <хеш2>

# 7. Удалить ветку (переключившись сначала на main)
git checkout main
git branch -D new_features
```

> **Совет:** Всегда проверяйте `git status` перед удалением веток и используйте `-d` вместо `-D`, чтобы Git предупредил о потенциальной потере данных.

--- 
