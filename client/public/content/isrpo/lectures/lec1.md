# Лекция №1. Git

---

## 1. Система контроля версий (СКВ): определение, назначение и роль в разработке

### 1.1. Определение

> **Система контроля версий** — это программное обеспечение, предназначенное для управления изменениями в файлах. Она обеспечивает фиксацию, хранение и контроль истории модификаций документа или проекта.

### 1.2. Ключевые возможности СКВ

1. **Ведение хронологической истории** — автоматическое сохранение последовательных версий файлов.  
2. **Возможность отката** — быстрое восстановление любой предыдущей стабильной версии.  
3. **Сравнение изменений** — анализ различий между версиями файлов.  
4. **Трассируемость** — фиксация автора, времени и цели каждого изменения.

### 1.3. Практический пример

Рассмотрим ситуацию, когда после добавления новой функции (например, таймера) в приложение обнаружен критический сбой:  
- **Без СКВ:** Требуется ручной поиск и отмена изменений, что ведёт к длительному простою.  
- **С использованием СКВ:** Возможен мгновенный откат к последней рабочей версии, что обеспечивает быстрое восстановление работоспособности.

### 1.4. Назначение и роль в разработке

СКВ решает несколько фундаментальных задач:  
1. **Управление историей изменений** — устранение необходимости ручного создания копий файлов.  
2. **Обеспечение стабильности** — защита проекта от последствий внедрения некорректных изменений.  
3. **Контроль и прозрачность** — отслеживание состояния файлов и активности разработчиков для координации работы.  
4. **Коллаборативная разработка** — безопасная параллельная работа команды над проектом с автоматическим управлением конфликтами.  
5. **Распространение кода** — обмен исходным кодом и привлечение сторонних разработчиков.

--- 

## 2. Архитектуры систем контроля версий

Существует три основных архитектурных подхода: **локальная**, **централизованная** и **распределённая**. Эволюция от локальной к распределённой системе была продиктована потребностями командной работы и надёжности.

### 2.1. Локальная система контроля версий

> **Локальная система контроля версий** — система, в которой история изменений хранится в локальной базе данных на компьютере пользователя.

**Преимущества:**  
- Работа без подключения к интернету.  
- Полная независимость от внешних серверов.

**Недостатки:**  
- Высокий риск потери всей истории при сбое компьютера.  
- Невозможность командной работы.

![Схема работы локальной СКВ](https://cithub.ru/api/files/isrpo_lec_1_21_1.png)

### 2.2. Централизованная система контроля версий

> **Централизованная система контроля версий** — архитектура, в которой существует единый центральный сервер, хранящий полную историю изменений. Разработчики получают из него файлы и отправляют обратно свои изменения.

**Примеры систем:** CVS, Subversion (SVN), Perforce.

**Преимущества:**  
- Возможность командной работы.  
- Централизованное управление правами и полная видимость процесса разработки.

**Недостатки:**  
- **Единая точка отказа:** при недоступности сервера работа парализуется.  
- **Риск потери данных:** при повреждении сервера без резервных копий теряется вся история проекта.  
- Зависимость от качества сетевого соединения.

![Схема работы централизованной СКВ](https://cithub.ru/api/files/isrpo_lec_1_22_1.png)

### 2.3. Распределённая система контроля версий

> **Распределённая система контроля версий** — архитектура, в которой каждый разработчик клонирует **полный репозиторий**, включая всю историю изменений.

**Примеры систем:** Git, Mercurial, Bazaar.

**Преимущества:**  
1. **Отказоустойчивость:** при падении основного сервера любой локальный репозиторий может быть использован для восстановления. Работа продолжается локально.  
2. **Гибкость работы:** поддержка множества удалённых репозиториев, что идеально подходит для open-source проектов и сложных workflows (форки, pull request’ы).

![Схема работы распределенной СКВ](https://cithub.ru/api/files/isrpo_lec_1_23_1.png)

--- 

## 3. Система контроля версий Git

> **Git** — ведущая современная распределённая система контроля версий с открытым исходным кодом, основанная на принципах распределённой архитектуры, но поддерживающая и полностью локальную работу.

### 3.1. Ключевые преимущества Git

1. **Полная локальная копия репозитория**  

Каждый разработчик хранит на своём компьютере полную копию проекта со всей историей изменений, что обеспечивает:  
- **Высокую скорость** выполнения операций.  
- **Автономную работу** без постоянного подключения к интернету.  
- **Простое управление** через одну скрытую папку `.git` в корне проекта.  
- **Свободу экспериментировать** с созданием веток и тестированием без влияния на общий код.

2. **Гибкое управление историей (коммитами)**  

Git предоставляет расширенные возможности для работы с коммитами:  
- Редактирование, удаление, объединение и разделение коммитов.  
- Перемещение коммитов между ветками.  

Это позволяет поддерживать чистую и логичную историю проекта.

3. **Мощная система веток (Branches)**  

Ветвление — фундаментальный принцип работы в Git:  
- Создание, переключение и слияние веток — быстрые и простые операции.  
- Короткоживущие ветки (1–3 дня) используются для разработки новых функций, исправления ошибок, после чего сливаются с основной веткой.  

Это позволяет вести параллельную разработку без риска нарушения стабильности основного кода.

4. **Точный контроль над коммитами**  

Коммит в Git фиксирует не файлы целиком, а конкретные изменения:  
- Можно включить в коммит только определённые файлы или даже части изменений внутри файла.  
- Детальный просмотр истории и сравнения между любыми версиями.

5. **Временное сохранение изменений (Stash)**  

Функция `git stash` позволяет «отложить» незавершённые изменения, чтобы временно переключиться на другую задачу или ветку, не создавая промежуточных коммитов.

6. **Эффективная командная работа**  

Рабочий процесс строится вокруг веток:  
- Каждая задача выполняется в отдельной ветке.  
- Перед слиянием с основной веткой код проходит проверку (code review).  

Такой подход гарантирует, что в основной код попадает только проверенный и рабочий функционал.

7. **Интеграция с облачными платформами (GitHub, BitBucket, GitLab)**  

Эти сервисы предоставляют удалённые репозитории для:  
- Хостинга и совместной работы над open-source и приватными проектами.  
- Организации процессов через forks, pull requests, issue tracking и code review.  
- Создания портфолио для разработчиков.

---

## 4. Основные понятия Git

### 4.1. Репозиторий

> **Репозиторий** — каталог проекта, в котором Git отслеживает изменения. Вся история и служебные данные хранятся в подкаталоге `.git`. Репозиторий может быть локальным или удалённым.

### 4.2. Коммит

> **Коммит** — фиксация изменений, добавленных в индекс. Каждый коммит содержит снимок файлов, автора, метку времени и уникальный идентификатор (хеш), позволяющий вернуться к этой версии.

### 4.3. Ветка

> **Ветка** — указатель на конкретный коммит, создающий независимую линию разработки. Ветки позволяют работать над разными задачами параллельно, не влияя на основной код. По умолчанию создаётся ветка `main` (или `master`).

### 4.4. Индекс

> **Индекс** (или *Staging Area*) — промежуточная область, куда помещаются изменения перед коммитом. Сюда файлы попадают командой `git add`, что позволяет точно выбирать, что войдёт в следующую фиксацию.

### 4.5. Рабочий каталог

> **Рабочий каталог** — текущие файлы проекта, с которыми вы работаете напрямую. Это видимая часть репозитория, не включающая служебные данные из `.git`.

### 4.6. HEAD

> **HEAD** — специальный указатель, который показывает, где вы находитесь в истории: на какой коммит или ветку сейчас ссылается репозиторий. Перемещается при переключении между коммитами или ветками.

---

## 5. Настройки Git

### 5.1. Уровни настроек

В Git существует три уровня настроек, которые определяют область их применения:

1. **Системные настройки**  

Действуют для **всех пользователей и репозиториев** на компьютере.  
Файл:  
- Windows: `C:\Program Files\Git\etc\gitconfig`  
- Linux/Mac: `/etc/gitconfig`

2. **Глобальные настройки**  

Применяются ко **всем репозиториям текущего пользователя**.  
Файл:  
- Windows: `C:\Users\<имя>\.gitconfig`  
- Linux/Mac: `~/.gitconfig`

3. **Локальные настройки**  

Действуют **только в рамках конкретного репозитория**.  
Файл: `.git/config`

> **Приоритет:** Локальные → Глобальные → Системные (локальные имеют наивысший приоритет).

### 5.2. Управление настройками через `git config`

**Формат команды**  
```bash
git config [<ключ-уровня>] <параметр> <значение>
```

**Ключи уровня (область действия)**  
- **Без ключа** — изменение настроек **локально**, только для текущего репозитория.  
- `--global` — изменение настроек **глобально**, для всех репозиториев текущего пользователя.  
- `--system` — изменение настроек **системно**, для всех пользователей компьютера (требует прав администратора).

**Основные параметры для настройки**  
- `user.name` — имя пользователя (отображается в авторах коммитов).  
- `user.email` — электронная почта пользователя (идентификатор для коммитов).

**Примеры использования**  
```bash
# Установка имени пользователя в текущем репозитории (локальный уровень)
$ git config user.name "John"

# Просмотр значения параметра
$ git config user.name
John

# Установка электронной почты глобально (для всех ваших проектов)
$ git config --global user.email "daniella@email.com"

# Просмотр всех настроек текущего уровня
$ git config --list

# Установка системной настройки (для всех пользователей)
$ git config --system color.ui auto
```

### 5.3. Прямое редактирование файлов

Можно редактировать конфигурационные файлы напрямую в текстовом редакторе:  
- Системный: `gitconfig` (в путях, указанных выше)  
- Глобальный: `.gitconfig` (в домашней директории пользователя)  
- Локальный: `.git/config` (в репозитории)

> **Рекомендуемый способ:** использование команды `git config`, так как она предотвращает ошибки синтаксиса.

---

## 6. Создание репозитория

Репозиторий Git создаётся, когда в папке проекта появляется служебная директория `.git`. Есть два основных способа её создания:  
1. **Инициализация нового репозитория** — начать отслеживание существующей папки.  
2. **Клонирование существующего репозитория** — скопировать удалённый репозиторий со всей историей на локальный компьютер.

### 6.1. Создание нового репозитория (`git init`)

> **Команда `git init`** — превращает текущую папку в репозиторий Git, создавая в ней скрытую папку `.git`.

**Формат команды**  
```bash
git init [опции]
```

**Назначение**  
Создаёт пустой репозиторий в текущей директории.

**Пример**  
```bash
# Переходим в папку проекта
$ cd projects/my_project

# Инициализируем репозиторий
$ git init
Initialized empty Git repository in /path/to/projects/my_project/.git/
```

**Что происходит после выполнения**  
- Создаётся скрытая папка `.git` со всей структурой Git.  
- Появляется начальная ветка (обычно `main` или `master`).  
- Папка готова к отслеживанию файлов и созданию коммитов.

> **Примечание:** Репозиторий, созданный через `git init`, изначально не связан с удалённым сервером. Связь можно добавить позже командой `git remote add`.

---

## 7. Состояния файлов и рабочие области Git

### 7.1. Три основные области Git

1. **Рабочий каталог (Working Directory)**  

Ваши текущие файлы проекта, с которыми вы работаете напрямую.

2. **Индекс (Index / Staging Area)**  

Промежуточная область, где находятся изменения, подготовленные для следующего коммита (после `git add`).

3. **Репозиторий (Git Directory)**  

База данных Git (папка `.git`), где хранятся все коммиты и история изменений.

> **Переходы между областями:**  
> Рабочий каталог → (`git add`) → Индекс → (`git commit`) → Репозиторий

### 7.2. Состояния файлов в Git

Каждый файл может находиться в одном из двух основных состояний:

**Отслеживаемые файлы (Tracked)**  
Файлы, известные Git (были в предыдущем коммите или добавлены в индекс). Имеют три подсостояния:  
- **Неизменённый (Unmodified)** — файл не менялся с последнего коммита.  
- **Изменённый (Modified)** — файл был изменён в рабочем каталоге.  
- **Подготовленный (Staged)** — изменения файла добавлены в индекс командой `git add` и готовы к коммиту.

**Неотслеживаемые файлы (Untracked)**  
Новые файлы, которые Git ещё не отслеживает (не были в коммитах и не добавлены в индекс).

### 7.3. Команда `git status`

> **Команда `git status`** — показывает текущее состояние файлов в рабочем каталоге и индексе.

**Формат команды**  
```bash
git status [опции]
```

**Назначение**  
Отображает список изменённых, подготовленных и неотслеживаемых файлов.

**Пример**  
```bash
# Создадим два файла
$ echo "a" > alpha.txt
$ echo "1" > num.txt

# Проверим статус
$ git status
On branch develop
No commits yet

Untracked files:
  (use "git add <file>..." to include in what will be committed)
        alpha.txt
        num.txt

nothing added to commit but untracked files present (use "git add" to track)
```

**Вывод команды показывает**  
- Текущую ветку (`On branch develop`)  
- Файлы в разных состояниях:  
  - **Untracked files** — неотслеживаемые  
  - **Changes to be committed** — подготовленные к коммиту  
  - **Changes not staged for commit** — изменённые, но не добавленные в индекс  
- Подсказки по дальнейшим действиям

> **Важно:** `git status` — основная команда для понимания, что происходит в репозитории перед созданием коммитов.

---

## 8. Внутреннее устройство Git: объекты

> **Объекты Git** — файлы в директории `.git/objects/`, в которых хранится вся информация репозитория; каждый объект имеет уникальный SHA-1 идентификатор.

### 8.1. Типы объектов Git

- **Blob (Binary Large Object)** — хранит сжатое содержимое файла (без имени и метаданных); создаётся при выполнении `git add`.  
- **Tree (Дерево)** — описывает структуру каталога, содержа список вложенных файлов (blob) и поддиректорий (tree); создаётся при коммите.  
- **Commit (Коммит)** — содержит метаданные фиксации: автора, дату, сообщение, ссылку на tree корневой директории и ссылку на родительский коммит.

### 8.2. Связь объектов

Объекты ссылаются друг на друга, образуя направленный граф:  
```
Коммит → Tree (корень) → [Blob (файл1), Tree (папка) → Blob (файл2)]
```

### 8.3. Файл индекса (Index)

> **Индекс** — служебный файл `.git/index`, выступающий промежуточной областью между рабочим каталогом и репозиторием; при выполнении `git add` создаётся blob-объект, и ссылка на него записывается в индекс, фиксируя изменения для следующего коммита.

--- 

## 9. Команда `git add`

> **Команда `git add`** — добавляет изменения из рабочего каталога в индекс (staging area), подготавливая их к коммиту.

**Формат команды**  
```bash
git add <путь_к_файлу> [флаги]
```

**Основные флаги**  
- `-A` или `--all` — добавляет все изменённые и новые файлы в репозитории.

**Примеры использования**  
```bash
# Добавить конкретный файл
$ git add file.cs

# Добавить все изменённые и новые файлы
$ git add -A
# или
$ git add --all
```

После выполнения команды файл попадает в индекс и становится отслеживаемым (staged).

**Пример проверки статуса**  
```bash
$ git status
On branch develop
No commits yet

Changes to be committed:
  (use "git rm --cached <file>..." to unstage)
        new file:   file.txt

Untracked files:
  (use "git add <file>..." to include in what will be committed)
        num.txt
```

**Как работает `git add` изнутри**  
1. **Создаёт blob-объект**  

Git сжимает содержимое файла, формирует заголовок вида `blob <размер>\0<содержимое>` и вычисляет SHA-1 хеш (40 символов).  
Пример хеша: `ca87a297fe24e72165a6c462b2e1df12a01cbc34`

2. **Сохраняет blob в `.git/objects/`**  

Объект сохраняется по пути:  
`.git/objects/ca/87a297fe24e72165a6c462b2e1df12a01cbc34`

3. **Добавляет запись в индекс**  

В файл `.git/index` добавляется строка с именем файла и его хешем:  
`file.txt ca87a297fe24e72165a6c462b2e1df12a01cbc34`

Если содержимое файла меняется, нужно снова выполнить `git add`, чтобы создать новый blob и обновить индекс.

--- 

## 10. Команда `git commit`

> **Команда `git commit`** — создаёт новый коммит, фиксирующий все изменения, добавленные в индекс (staging area).

**Формат команды**  
```bash
git commit [флаги]
```

**Основные флаги**  
- **`-m "описание"`** — добавляет сообщение коммита напрямую из командной строки.  
  Пример: `git commit -m "Добавил новую функцию"`  
- **`-c <хэш_коммита>`** — использует сообщение и автора из указанного коммита, открывая редактор для редактирования сообщения.  
- **`-C <хэш_коммита>`** — аналогично `-c`, но без открытия редактора (сообщение копируется без изменений).

**Пример использования**  
```bash
$ git commit -m "Add math hometask"
[master 0b1f669] Add math hometask
 11 files changed, 7 insertions(+), 638 deletions(-)
 rewrite .gitignore (99%)
 delete mode 100644 discrete math/hw-3/dm3.pdf
```

Вывод показывает:  
- Ветку (`master`)  
- Короткий хеш коммита (`0b1f669`)  
- Сообщение коммита  
- Статистику изменений

**Как работает `git commit` изнутри**  
1. **Создаёт tree-объекты**  

На основе файлов в индексе Git строит граф (дерево) структуры проекта, где каждая папка представлена tree-объектом, а каждый файл — blob-объектом.

2. **Создаёт объект коммита**  

Формируется объект, содержащий:  
- Ссылку на tree корневой директории  
- Автора, дату и время  
- Сообщение коммита  
- Ссылку на родительский коммит (или коммиты)

3. **Обновляет указатель ветки**  

Текущая ветка (например, `master`) перемещается на вновь созданный коммит.

> **Важно:** Коммит фиксирует только те изменения, которые были предварительно добавлены в индекс командой `git add`.

--- 