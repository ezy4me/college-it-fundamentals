# Лекция №7. Функции в JavaScript: области видимости, замыкания и стек вызовов

---

## 1. Области видимости

В JavaScript область видимости (scope) — это зона действия переменных, функций и параметров. Понимание областей видимости помогает избежать конфликтов между переменными и правильно управлять памятью.

> **Область видимости** — это контекст, в котором переменные и функции объявляются и к которому можно получить доступ.

Существует три основных типа области видимости:

- **Глобальная** — доступна везде
- **Функциональная** — доступна только внутри функции
- **Блочная** — доступна внутри блока (`{ ... }`), например, в `if`, `for`

Также важно понимать, как вложенные области взаимодействуют друг с другом: внутренняя область имеет доступ к переменным из внешней, но не наоборот.

---

### 1.1. Глобальная область

Глобальная область — это корневая область, доступная во всём скрипте. Любая переменная, объявленная вне функций и блоков, попадает в глобальную область.

**Пример:**

```javascript
let siteName = 'example.com';

function showSite() {
  console.log(siteName); // Доступ к глобальной переменной
}

showSite(); // → example.com
```

**Особенности:**

- Глобальные переменные могут быть доступны и изменены из любого места в коде
- В браузере глобальные переменные становятся свойствами объекта `window`

```javascript
var user = 'Анна';
console.log(window.user); // → 'Анна'
```

> **Важно:** Слишком активное использование глобальных переменных может привести к конфликтам и ошибкам. Хорошая практика — сводить глобальные переменные к минимуму.

---

### 1.2. Функциональная область

Функциональная область создаётся при вызове функции. Все переменные, объявленные внутри функции с помощью `var`, `let` или `const`, доступны только внутри этой функции.

**Пример:**

```javascript
function greet() {
  let message = 'Привет!';
  console.log(message);
}

greet();            // → Привет!
console.log(message); // ❌ Ошибка: message не определена
```

Переменная `message` существует только внутри функции `greet`. За пределами этой функции она недоступна.

**Параметры функции — это тоже локальные переменные**

```javascript
function sayHi(name) {
  console.log('Привет, ' + name);
}

sayHi('Катя');         // → Привет, Катя
console.log(name);     // ❌ Ошибка: name не определено
```

Параметр `name` доступен только внутри тела функции `sayHi`.

**Особенности:**

- Переменные внутри функции изолированы — это защищает их от конфликтов
- Даже если переменные в разных функциях называются одинаково — они не мешают друг другу:

```javascript
function a() {
  let count = 1;
  console.log(count);
}

function b() {
  let count = 2;
  console.log(count);
}

a(); // → 1
b(); // → 2
```

---

### 1.3. Блочная область (let, const)

Блочная область (block scope) — это область, ограниченная фигурными скобками `{}`. Переменные, объявленные с помощью `let` или `const` внутри блока, не видны снаружи этого блока.

Блоком может быть:
- `if`, `else`
- `for`, `while`
- `switch`, `try...catch`

**Пример с if:**

```javascript
if (true) {
  let secret = 'скрытое значение';
  console.log(secret); // → скрытое значение
}

console.log(secret); // ❌ Ошибка: secret не определена
```

**Пример с for:**

```javascript
for (let i = 0; i < 3; i++) {
  console.log(i); // → 0, 1, 2
}

console.log(i); // ❌ Ошибка: i не определена
```

**В чём отличие от var?**

Переменные, объявленные с помощью `var`, игнорируют блочную область — они видны за пределами блока:

```javascript
if (true) {
  var test = 'видно везде';
}

console.log(test); // → видно везде
```

Поэтому `let` и `const` считаются более безопасными: они сохраняют переменные только там, где они действительно нужны.

---

### 1.4. Вложенность и доступ к переменным

JavaScript поддерживает вложенные области видимости: внутренняя область имеет доступ к переменным из внешней, но не наоборот.

**Пример:**

```javascript
let a = 'внешняя';

function outer() {
  let b = 'средняя';

  function inner() {
    let c = 'внутренняя';
    console.log(a); // → внешняя
    console.log(b); // → средняя
    console.log(c); // → внутренняя
  }

  inner();
  // console.log(c); // ❌ Ошибка: c не определена
}

outer();
```

Внутренняя функция `inner` имеет доступ ко всем переменным, определённым в `outer`, и даже к глобальной переменной `a`. Но `outer` не может получить доступ к переменной `c`, так как она определена глубже.

Это поведение лежит в основе замыканий и лексического окружения, о которых мы поговорим позже.

---

## 2. Hoisting (поднятие)

Hoisting — это механизм в JavaScript, при котором объявления переменных и функций «поднимаются» (то есть становятся известны интерпретатору) в начало своей области видимости до выполнения кода. Это значит, что вы можете обращаться к переменным и функциям до их фактического объявления, но с оговорками.

> **Hoisting** — это механизм, при котором объявления переменных и функций перемещаются вверх своей области видимости перед выполнением кода.

**Важно:** поднимаются только объявления, а не инициализации (присваивания).

---

### 2.1. Hoisting для var

Переменные, объявленные с помощью `var`, поднимаются в начало своей функции или глобальной области видимости.

**Пример (с var):**

```javascript
console.log(x); // → undefined
var x = 10;
```

Этот код интерпретируется как:

```javascript
var x;
console.log(x); // undefined
x = 10;
```

---

### 2.2. Hoisting для function declaration

Функции, объявленные через `function имя() { ... }`, поднимаются полностью — и объявление, и тело функции.

**Пример:**

```javascript
sayHello(); // → Привет!

function sayHello() {
  console.log('Привет!');
}
```

Можно вызывать функцию до её объявления в коде, и всё будет работать.

---

### 2.3. Особенности let и const (TDZ — Temporal Dead Zone)

Переменные, объявленные с помощью `let` и `const`, тоже поднимаются, но не инициализируются сразу. Между началом области видимости и объявлением переменной существует так называемая "временная мёртвая зона" (TDZ).

> **Temporal Dead Zone (TDZ)** — это период между началом области видимости и моментом объявления переменной, когда к переменной нельзя получить доступ.

**Пример:**

```javascript
console.log(y); // Ошибка ReferenceError: нельзя использовать до объявления
let y = 20;
```

Т.е. доступ к переменным `let` и `const` до их объявления приводит к ошибке, в отличие от `var`, где будет `undefined`.

**Пример:**

```javascript
// var
console.log(a); // undefined
var a = 5;

// let
console.log(b); // ReferenceError
let b = 10;

// const
console.log(c); // ReferenceError
const c = 15;

// function declaration
foo(); // работает
function foo() {
  console.log('foo');
}

// function expression (var)
bar(); // TypeError: bar is not a function
var bar = function() {
  console.log('bar');
};
```

---

### 2.4. Разница между var, let и const

**Область видимости:**

| Ключевое слово | Область видимости |
|----------------|-------------------|
| `var` | Функциональная или глобальная |
| `let` | Блочная (в пределах `{ ... }`) |
| `const` | Блочная (в пределах `{ ... }`) |

**Пример:**

```javascript
if (true) {
  var x = 1;
  let y = 2;
  const z = 3;
}

console.log(x); // 1 — var игнорирует блок
console.log(y); // Ошибка, y не доступна
console.log(z); // Ошибка, z не доступна
```

**Поведение при hoisting:**

- `var` — объявляется и инициализируется как `undefined` до выполнения кода
- `let` и `const` — объявляются, но не инициализируются (TDZ). Использование до объявления вызовет ошибку

**Повторное объявление:**

| Ключевое слово | Повторное объявление в одной области |
|----------------|--------------------------------------|
| `var` | Разрешено |
| `let` | Ошибка |
| `const` | Ошибка |

**Пример:**

```javascript
var a = 1;
var a = 2; // OK

let b = 1;
let b = 2; // Ошибка: Identifier 'b' has already been declared

const c = 1;
const c = 2; // Ошибка: Identifier 'c' has already been declared
```

**Изменяемость значений:**

- `var` и `let` позволяют изменять значение переменной
- `const` — переменная с константным значением, которое нельзя изменить после присвоения

**Пример:**

```javascript
let a = 5;
a = 10; // OK

const b = 20;
b = 30; // Ошибка — нельзя переназначать

const obj = { name: "Anna" };
obj.name = "Olga"; // OK — изменяется свойство объекта, а не сама ссылка

console.log(obj.name); // "Olga"
```

---

## 3. Замыкания (Closures) и лексическое окружение

### 3.1. Что такое замыкание

Замыкание — это функция, которая запоминает переменные из своей внешней области видимости, даже после того как внешняя функция уже завершила выполнение.

> **Замыкание** — это комбинация функции и лексического окружения, в котором эта функция была объявлена.

Иными словами, функция "замыкает" доступ к переменным, к которым она имела доступ в момент своего создания. Это поведение становится возможным благодаря лексическому окружению — мы разберём его подробнее в следующем разделе.

**Простой пример:**

```javascript
function outer() {
  let counter = 0;

  return function inner() {
    counter++;
    console.log(counter);
  };
}

const count = outer();

count(); // 1
count(); // 2
count(); // 3
```

**Что происходит:**

- Вызов `outer()` создаёт переменную `counter` и возвращает внутреннюю функцию `inner`
- Хотя `outer()` уже завершился, функция `inner` всё ещё имеет доступ к `counter` — это и есть замыкание

**Где это используется:**

- Создание приватных данных в JavaScript
- Организация инкапсуляции
- Фабрики функций (функции, возвращающие другие функции с "памятью")
- Асинхронное программирование — например, `setTimeout`, колбэки и обработчики событий

---

### 3.2. Лексическое окружение

Лексическое окружение — это структура, в которой JavaScript хранит переменные, объявленные в текущей и внешних областях видимости. Оно формируется в момент объявления функции, а не в момент её вызова. Именно это объясняет, как работают замыкания.

> **Лексическое окружение** — это внутренняя структура, которая содержит ссылки на переменные и функции, доступные в текущей области видимости.

**Пример:**

```javascript
function outer() {
  let message = "Привет из внешней функции";

  function inner() {
    console.log(message);
  }

  return inner;
}

const greet = outer();
greet(); // → Привет из внешней функции
```

**Пояснение:**

- Функция `inner` была создана внутри `outer`, значит, она лексически связана с областью видимости `outer`
- Даже после завершения `outer`, переменная `message` не удаляется, потому что на неё ссылается `inner`

**Как это работает?**

Каждая функция в JS при создании получает ссылку на лексическое окружение, в котором была определена. Это окружение включает:

1. Все локальные переменные
2. Ссылку на внешнее окружение (вплоть до глобального)

Таким образом, вложенные функции всегда "помнят", где были созданы и имеют доступ к этим переменным, даже если вызываются из другого контекста.

---

### 3.3. Практические примеры использования

Замыкания применяются в реальных задачах чаще, чем кажется. Вот несколько типичных и полезных сценариев:

**1. Функция-счётчик**

```javascript
function createCounter() {
  let count = 0;

  return function () {
    count++;
    return count;
  };
}

const counter = createCounter();

console.log(counter()); // → 1
console.log(counter()); // → 2
console.log(counter()); // → 3
```

**Что происходит:** функция `createCounter` создаёт лексическое окружение с переменной `count`. Возвращаемая функция имеет доступ к `count` даже после того, как `createCounter` завершила выполнение.

**2. Инкапсуляция состояния (без глобальных переменных)**

```javascript
function createUser(name) {
  let _name = name;

  return {
    getName() {
      return _name;
    },
    setName(newName) {
      _name = newName;
    },
  };
}

const user = createUser("Катя");
console.log(user.getName()); // → Катя

user.setName("Оля");
console.log(user.getName()); // → Оля
```

**Что происходит:** переменная `_name` скрыта от внешнего мира — доступ к ней возможен только через возвращаемые методы. Это своего рода приватность, реализованная через замыкания.

**3. Обработчики событий с сохранением состояния**

```javascript
function handleClick(message) {
  return function () {
    alert(message);
  };
}

const button = document.querySelector("button");
button.addEventListener("click", handleClick("Кнопка нажата!"));
```

**Что происходит:** функция, которую мы передаём в `addEventListener`, сохраняет в своём замыкании переменную `message`, даже если срабатывает позже.

---

## 4. Функции

Функции — ключевой строительный блок в JavaScript. Они позволяют организовать код, переиспользовать логику и управлять потоком выполнения.

> **Функция** — это блок кода, который можно выполнять многократно, передавая ему различные параметры.

Существует несколько способов создания функций, и каждый из них имеет свои особенности:

- Function Declaration
- Function Expression
- Arrow Function

---

### 4.1. Function Declaration (Объявление функции)

Это классический способ определения функции.

```javascript
function sayHello(name) {
  console.log("Привет, " + name);
}

sayHello("Анна"); // → Привет, Анна
```

**Особенности:**

- Поднимается (hoisting): можно вызвать функцию до её объявления
- Удобно для описания основного потока логики

---

### 4.2. Function Expression (Функциональное выражение)

Функция присваивается переменной.

```javascript
const greet = function(name) {
  console.log("Привет, " + name);
};

greet("Оля"); // → Привет, Оля
```

**Особенности:**

- Не поднимается как целое: `greet()` до объявления вызовет ошибку
- Часто используется при передаче функций как аргументов

---

### 4.3. Arrow Function (Стрелочная функция)

Более короткий синтаксис, особенно полезен в коллбэках.

```javascript
const multiply = (a, b) => a * b;

console.log(multiply(3, 4)); // → 12
```

Если тело содержит более одной строки, нужны фигурные скобки и `return`:

```javascript
const divide = (a, b) => {
  if (b === 0) return "Ошибка";
  return a / b;
};
```

---

### 4.4. Отличия между типами функций

| Характеристика | Function Declaration | Function Expression | Arrow Function |
|----------------|---------------------|---------------------|----------------|
| Поднимается (hoisting) | Да | Нет | Нет |
| Имеет свой `this` | Да | Да | Нет (наследует) |
| Синтаксис | Стандартный | Присваивается | Компактный |
| Подходит для методов | Да | Да | Иногда (без `this`) |

**Пример:**

```javascript
const user = {
  name: "Катя",
  regularFunc: function () {
    console.log("regularFunc:", this.name);
  },
  arrowFunc: () => {
    console.log("arrowFunc:", this.name);
  },
};

user.regularFunc(); // → Катя
user.arrowFunc();   // → undefined (this не связан с user)
```

---

## 5. Контекст выполнения

Ключевое слово `this` в JavaScript указывает на объект, в контексте которого была вызвана функция. В отличие от многих языков, в JavaScript `this` не определяется местом объявления функции, а зависит от способа вызова.

---

### 5.1. Что такое this

`this` — это ссылка на текущий контекст выполнения. Он может меняться в зависимости от:

- Где и как была вызвана функция
- Используется ли стрелочная функция
- Является ли код строгим (`'use strict'`)

> **this** — это специальная переменная, которая ссылается на объект, в контексте которого выполняется функция.

---

### 5.2. Как определяется this в разных случаях

**1. Метод объекта**

Если функция вызывается как метод объекта — `this` указывает на этот объект.

```javascript
const user = {
  name: "Аня",
  sayHi() {
    console.log(this.name);
  }
};

user.sayHi(); // → "Аня"
```

**2. Обычная функция**

Если функция вызывается как обычная (не как метод), то:
- в нестрогом режиме `this` указывает на глобальный объект (`window`)
- в строгом режиме — `undefined`

```javascript
function test() {
  console.log(this);
}

test(); // → window (или undefined в 'use strict')
```

**3. Стрелочная функция**

Стрелочные функции не имеют собственного `this` — они берут `this` из внешнего контекста, в котором были определены.

```javascript
const user = {
  name: "Оля",
  sayHi: () => {
    console.log(this.name);
  }
};

user.sayHi(); // → undefined
```

Причина — `this` здесь не связан с `user`, а наследуется от внешнего контекста, где `this = window`.

**4. В конструкторах**

При использовании с `new`, `this` ссылается на только что созданный объект.

```javascript
function User(name) {
  this.name = name;
}

const u = new User("Катя");
console.log(u.name); // → "Катя"
```

**5. Ручная привязка: call, apply, bind**

JavaScript позволяет вручную задать `this` с помощью этих методов.

```javascript
function greet() {
  console.log("Привет, " + this.name);
}

const person = { name: "Ира" };

greet.call(person);  // → Привет, Ира
greet.apply(person); // → Привет, Ира

const bound = greet.bind(person);
bound(); // → Привет, Ира
```

**Основные особенности:**

- Значение `this` определяется в момент вызова, а не при объявлении
- Стрелочные функции не имеют собственного `this`
- `call`, `apply`, `bind` позволяют явно задать `this`

---

## 6. Call Stack (стек вызовов)

JavaScript — однопоточный язык, который выполняет код последовательно, используя специальную структуру данных — Call Stack (стек вызовов). Понимание работы Call Stack помогает понять, как происходит вызов функций, как формируется контекст выполнения и откуда берётся значение `this`.

---

### 6.1. Что такое Call Stack?

- **Call Stack** — это стек, в который помещаются функции по мере их вызова
- Когда функция вызывается, она кладётся сверху стека
- Когда функция заканчивает выполнение, она снимается со стека
- JavaScript всегда выполняет функцию, которая находится на вершине стека

> **Call Stack** — это структура данных, которая отслеживает вызовы функций и управляет порядком их выполнения.

**Пример:**

```javascript
function first() {
  console.log('Первый вызов'); // → вывод: Первый вызов
  second();
  console.log('Первый вызов завершён'); // → вывод: Первый вызов завершён
}

function second() {
  console.log('Второй вызов'); // → вывод: Второй вызов
}

first();
```

**Пошагово что происходит:**

1. Вызов `first()` — кладём функцию `first` в стек вызовов
2. Выполняется `console.log('Первый вызов')` — в консоль выводится `Первый вызов`
3. Внутри `first()` вызывается `second()` — кладём функцию `second` в стек
4. Выполняется `console.log('Второй вызов')` внутри `second` — вывод: `Второй вызов`
5. `second()` заканчивается, снимается со стека
6. Возвращаемся в `first()`, продолжаем выполнение: `console.log('Первый вызов завершён')` — вывод: `Первый вызов завершён`
7. `first()` заканчивается, снимается со стека

**Итоговый вывод в консоль:**
```
Первый вызов
Второй вызов
Первый вызов завершён
```

**Контекст выполнения и this**

Каждый раз при вызове функции создаётся контекст выполнения — набор информации о том, где и как функция была вызвана, включая:

- Значение `this`
- Переменные, объявленные внутри функции
- Ссылку на внешнюю область видимости (для замыканий)

Значение `this` зависит от того, как функция была вызвана, и вычисляется при создании контекста выполнения.

**Как Call Stack связан с this?**

- Контекст выполнения создаётся для каждой функции в стеке
- В момент создания контекста JS определяет значение `this` в зависимости от способа вызова

Например:

- Если функция вызвана как метод объекта — `this` указывает на объект
- Если функция вызвана сама по себе — `this` указывает на глобальный объект (или `undefined` в строгом режиме)
- Если функция вызвана через `call`, `apply` или `bind` — `this` устанавливается явно

**Почему понимание Call Stack важно?**

- Помогает понять ошибки типа "Maximum call stack size exceeded" (бесконечная рекурсия)
- Объясняет порядок выполнения вложенных вызовов
- Показывает, почему `this` может менять значение при вызове функций из разных мест