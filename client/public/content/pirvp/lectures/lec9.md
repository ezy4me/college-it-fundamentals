# Лекция №9. Асинхронность, Event Loop, Promises, async/await

---

## 1. Асинхронный код в JavaScript

### 1.1. Что такое асинхронность?

Асинхронность — это способ выполнения операций, при котором код не ждет завершения задачи, а продолжает работать дальше.

> **Асинхронность** — это подход к выполнению операций, при котором программа не блокируется в ожидании результата, а продолжает выполнять другие задачи.

Например: ты отправляешь запрос к серверу и не ждёшь ответа, а делаешь другие дела. Когда ответ приходит — программа обрабатывает его.

### 1.2. Почему это важно?

JavaScript работает по очереди — выполняет одну задачу за другой. Если задача очень долгая (например, запрос к серверу или таймер), весь код остановится и «замрёт».

Асинхронность помогает не ждать долго, а выполнять другие задачи, пока первая ещё не закончилась.

### 1.3. Асинхронные операции (setTimeout, setInterval, fetch)

Асинхронные операции — это задачи, которые не выполняются сразу, а запускаются параллельно с остальным кодом, и результат приходит позже. Такие операции не блокируют выполнение остального кода.

**1. setTimeout — запуск функции с задержкой**

```javascript
console.log('Перед setTimeout');

setTimeout(() => {
  console.log('Этот код выполнится через 2 секунды');
}, 2000);

console.log('После setTimeout');
```

**Порядок вывода в консоль:**
1. "Перед setTimeout" — выводится сразу
2. "После setTimeout" — выводится сразу после предыдущей строки
3. Через 2 секунды — "Этот код выполнится через 2 секунды"

То есть, код внутри setTimeout выполнится позже, после задержки, а не сразу.

**2. setInterval — повторный запуск функции с интервалом**

```javascript
let count = 0;

const intervalId = setInterval(() => {
  count++;
  console.log(`Прошло ${count} секунд`);

  if (count === 5) {
    clearInterval(intervalId); // останавливаем интервал после 5 повторений
    console.log('Интервал остановлен');
  }
}, 1000);
```

**Порядок вывода в консоль:**
- Каждую секунду выводится строка:
  - "Прошло 1 секунд"
  - "Прошло 2 секунд"
  - "Прошло 3 секунд"
  - "Прошло 4 секунд"
  - "Прошло 5 секунд"
- После пятого сообщения выводится "Интервал остановлен"
- Между этими сообщениями основная программа может выполнять другие операции (если они есть)

**3. fetch — асинхронный запрос к серверу**

```javascript
console.log('Начинаем загрузку данных');

fetch('https://jsonplaceholder.typicode.com/posts/1')
  .then(response => response.json())
  .then(data => {
    console.log('Данные получены:', data);
  })
  .catch(error => {
    console.error('Ошибка при загрузке:', error);
  });

console.log('Запрос отправлен, ждем ответ');
```

**Порядок вывода в консоль:**
1. "Начинаем загрузку данных" — выводится сразу
2. "Запрос отправлен, ждем ответ" — выводится сразу после предыдущей строки
3. Через некоторое время (зависит от сети и сервера) — "Данные получены: ..." или "Ошибка при загрузке: ..."

Запрос выполняется асинхронно, не блокируя основной поток.

---

## 2. Событийный цикл (Event Loop)

Чтобы работать с асинхронными операциями (например, таймерами, запросами или событиями), используется механизм, который называется событийный цикл — Event Loop.

> **Event Loop** — это механизм, который координирует выполнение кода, сбор событий и обработку очередей задач в JavaScript.

Event Loop — это процесс, который постоянно проверяет, есть ли в очереди задачи, которые нужно выполнить, и передаёт их для обработки в главный поток выполнения.

### 2.1. Стек вызовов (Call Stack)

Call Stack — это структура данных, которая хранит текущие выполняемые функции в порядке их вызова.

- Когда вызывается функция, она помещается на верх стека
- Когда функция заканчивается, она удаляется со стека
- Вся работа JavaScript идёт через этот стек — он управляет, что и когда выполняется

> **Call Stack** — это структура данных "последний пришел - первый ушел" (LIFO), которая отслеживает выполняемые функции.

**Пример Call Stack**

```javascript
function first() {
  console.log('Первый');
  second();
  console.log('Первый снова');
}

function second() {
  console.log('Второй');
}

first();
```

**Что происходит со стеком вызовов:**
1. Вызов `first()` кладётся в стек
2. Внутри `first()` выводится "Первый"
3. Вызов `second()` кладётся в стек поверх `first()`
4. В `second()` выводится "Второй"
5. `second()` заканчивается — удаляется из стека
6. Возврат к `first()` — выводится "Первый снова"
7. `first()` заканчивается — удаляется из стека
8. Стек пуст — выполнение кода завершено

Call Stack работает только с синхронным кодом — асинхронные операции (таймеры, сетевые запросы) не помещаются сюда напрямую. Вместо этого они обрабатываются через Web APIs и очереди задач, о которых поговорим дальше.

### 2.2. Web APIs и очередь задач (Task Queue / Callback Queue)

**Что такое Web APIs?**

В браузере есть специальные встроенные функции и возможности, которые называются Web APIs. Они предоставляют JavaScript доступ к таймерам (`setTimeout`, `setInterval`), сетевым запросам (`fetch`), событиям и многому другому.

> **Web APIs** — это набор API, предоставляемых браузером для работы с таймерами, сетью, DOM и другими возможностями.

Важно: эти Web APIs не часть самого JavaScript, а работают в окружении браузера или Node.js. JavaScript просто вызывает их, а они выполняют задачи асинхронно.

**Что такое очередь задач (Task Queue)?**

Когда Web API завершает свою работу (например, таймер истёк или сетевой запрос ответил), он помещает колбэк (функцию обратного вызова) в специальную очередь — очередь задач (Task Queue или Callback Queue).

> **Task Queue** — это очередь, в которую помещаются колбэки от асинхронных операций для последующего выполнения.

**Как это работает с Event Loop?**

- Event Loop проверяет, пуст ли стек вызовов (Call Stack)
- Если стек пуст, Event Loop берёт из очереди задач первую функцию и помещает её в стек для выполнения
- Так происходит выполнение асинхронного кода после завершения текущих синхронных операций

**Пример: setTimeout и очередь задач**

```javascript
console.log('1. Начало');

setTimeout(() => {
  console.log('4. Выполнен setTimeout');
}, 0);

console.log('2. Продолжаем работу');

setTimeout(() => {
  console.log('5. Второй setTimeout');
}, 10);

console.log('3. Конец');
```

**Пояснение порядка вывода:**
1. "1. Начало" — сразу
2. "2. Продолжаем работу" — сразу
3. "3. Конец" — сразу
4. "4. Выполнен setTimeout" — первый таймаут, встал в очередь задач и выполнится после пустого стека
5. "5. Второй setTimeout" — второй таймаут с задержкой 10мс, выполнится после первого

**Важно:**
- Web API асинхронно выполняет свои задачи (например, считает таймер или ждёт ответ от сервера)
- Когда задача готова, Web API кладёт callback в очередь задач
- Event Loop следит за стеком и, когда он пуст, берет задачу из очереди и запускает её

### 2.3. Микрозадачи vs Макрозадачи (Microtasks vs Macrotasks)

В Event Loop существует две очереди асинхронных задач:
- **Макрозадачи (Macrotasks)** — помещаются в Task Queue
- **Микрозадачи (Microtasks)** — помещаются в Microtask Queue

> **Микрозадачи** — это задачи с высоким приоритетом, которые выполняются сразу после текущего синхронного кода, но до следующих макрозадач.

> **Макрозадачи** — это задачи с обычным приоритетом, которые выполняются после всех микрозадач.

Микрозадачи — это задачи, которые имеют более высокий приоритет и выполняются сразу после завершения текущего стека вызовов, до перехода к следующим макрозадачам.

Макрозадачи — это задачи, которые обрабатываются по одной, после выполнения всех микрозадач. Каждая итерация событийного цикла обрабатывает одну макрозадачу и затем все накопленные микрозадачи.

**Примеры микрозадач:**
- `.then()` у Promise
- `queueMicrotask()`

**Примеры макрозадач:**
- `setTimeout()`
- `setInterval()`

**Порядок выполнения:**
1. Выполняется весь синхронный код
2. Выполняются все микрозадачи из очереди microtask
3. Выполняется одна макрозадача из task queue
4. Снова выполняются микрозадачи, если они были добавлены во время макрозадачи
5. Переход к следующей макрозадаче

**Пример 1:**

```javascript
console.log('1. Начало'); // синхронный

setTimeout(() => {
  console.log('4. setTimeout'); // макрозадача
}, 0);

Promise.resolve().then(() => {
  console.log('3. Promise.then'); // микрозадача
});

console.log('2. Конец'); // синхронный
```

**Пример 2:**

```javascript
console.log('1'); 

Promise.resolve().then(() => {
  console.log('2');
  return Promise.resolve();
}).then(() => {
  console.log('3');
});

setTimeout(() => {
  console.log('4');
}, 0);

console.log('5'); // 1 5 2 3 4
```

---

## 3. Callback (колбэк)

### 3.1. Как работают колбэки

Колбэк (callback) — это функция, переданная другой функции в качестве аргумента, которая будет вызвана позже, обычно по завершении асинхронной операции.

> **Callback** — это функция, передаваемая в качестве аргумента другой функции для последующего вызова.

**Пример:**

```javascript
function greet(name, callback) {
  console.log('Привет, ' + name);
  callback();
}

function sayBye() {
  console.log('Пока!');
}

greet('Анна', sayBye);
```

**Вывод:**
1. Привет, Анна
2. Пока!

Callback `sayBye` вызывается после выполнения основной логики `greet`.

### 3.2. Проблема callback hell (ад колбэков)

Когда колбэки вложены друг в друга, особенно в асинхронных операциях, код становится трудно читаемым и поддерживаемым. Это называют callback hell или "ад колбэков".

> **Callback Hell** — это ситуация, когда множество вложенных колбэков делает код сложным для чтения и поддержки.

**Пример:**

```javascript
setTimeout(() => {
  console.log('Шаг 1');
  setTimeout(() => {
    console.log('Шаг 2');
    setTimeout(() => {
      console.log('Шаг 3');
    }, 1000);
  }, 1000);
}, 1000);
```

**Вывод:**
1. (через 1 секунду) Шаг 1  
2. (еще через 1 секунду) Шаг 2  
3. (еще через 1 секунду) Шаг 3

Такой код сложно масштабировать и отлаживать.

### 3.3. Решение: промисы

Чтобы избежать вложенности и сделать код чище, были введены промисы — специальный объект, представляющий результат асинхронной операции.

**Тот же пример с Promise:**

```javascript
function delay(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

delay(1000)
  .then(() => {
    console.log('Шаг 1');
    return delay(1000);
  })
  .then(() => {
    console.log('Шаг 2');
    return delay(1000);
  })
  .then(() => {
    console.log('Шаг 3');
  });
```

---

## 4. Промисы (Promise)

### 4.1. Состояния промиса

Промис — это объект, представляющий результат асинхронной операции. У него есть три состояния:

- **`pending`** — начальное состояние (ожидает результат)
- **`fulfilled`** — операция завершилась успешно
- **`rejected`** — операция завершилась с ошибкой

> **Promise** — это объект, представляющий результат асинхронной операции, который может быть получен в будущем.

### 4.2. Создание промиса

Промис создаётся через `new Promise((resolve, reject) => { ... })`, где:
- `resolve(value)` — вызывается при успешном завершении
- `reject(error)` — вызывается при ошибке

**Пример:**

```javascript
const myPromise = new Promise((resolve, reject) => {
  const success = true;

  if (success) {
    resolve('Успешно!');
  } else {
    reject('Произошла ошибка');
  }
});
```

### 4.3. Методы .then(), .catch(), .finally()

- **`.then(callback)`** — вызывается при `resolve`
- **`.catch(callback)`** — вызывается при `reject`
- **`.finally(callback)`** — вызывается в любом случае

**Пример:**

```javascript
myPromise
  .then(result => {
    console.log('Результат:', result);
  })
  .catch(error => {
    console.error('Ошибка:', error);
  })
  .finally(() => {
    console.log('Операция завершена');
  });
```

**Возможные выводы:**
```
Результат: Успешно!
Операция завершена
```
или
```
Ошибка: Произошла ошибка
Операция завершена
```

### 4.4. Promise chaining (цепочки)

Можно возвращать новый промис в `.then()` и строить цепочку.

**Пример:**

```javascript
function delay(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

delay(1000)
  .then(() => {
    console.log('1 секунда прошла');
    return delay(1000);
  })
  .then(() => {
    console.log('2 секунды прошли');
  });
```

**Вывод:**
1. (после 1 сек) 1 секунда прошла  
2. (еще через 1 сек) 2 секунды прошли

### 4.5. Promise.all и Promise.race

- **`Promise.all([p1, p2, ...])`** — ждет, пока все промисы выполнятся
- **`Promise.race([p1, p2, ...])`** — возвращает результат первого завершившегося (неважно — с ошибкой или нет)

**Пример с Promise.all:**

```javascript
Promise.all([
  delay(1000).then(() => '1'),
  delay(2000).then(() => '2')
]).then(values => {
  console.log('Все готовы:', values);
});
```

**Вывод (через 2 секунды):**
```
Все готовы: [ '1', '2' ]
```

**Пример с Promise.race:**

```javascript
Promise.race([
  delay(1000).then(() => 'Первый'),
  delay(2000).then(() => 'Второй')
]).then(value => {
  console.log('Первым завершился:', value);
});
```

**Вывод (через 1 секунду):**
```
Первым завершился: Первый
```

---

## 5. async/await

async/await — это современный синтаксис для работы с промисами. Он делает асинхронный код более читаемым и похожим на обычный синхронный.

> **async/await** — это синтаксический сахар над промисами, который делает асинхронный код более читаемым и похожим на синхронный.

### 5.1. Синтаксис async и await

- **`async`** — ключевое слово перед функцией. Такая функция всегда возвращает промис
- **`await`** — ставится перед промисом и «ждёт» его завершения (работает только внутри async функции)

**Пример:**

```javascript
function delay(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

async function run() {
  console.log('Начало');
  await delay(1000);
  console.log('Прошла 1 секунда');
}

run();
```

**Вывод:**
1. Начало  
2. (через 1 сек) Прошла 1 секунда

### 5.2. Как async/await упрощает промисы

**Сравним цепочку промисов и async/await:**

**Цепочка через then:**
```javascript
fetch('/user.json')
  .then(response => response.json())
  .then(user => {
    console.log(user.name);
  })
  .catch(error => console.error(error));
```

**То же через async/await:**
```javascript
async function loadUser() {
  try {
    const response = await fetch('/user.json');
    const user = await response.json();
    console.log(user.name);
  } catch (error) {
    console.error(error);
  }
}

loadUser();
```

Код с async/await легче читать и сопровождать.

### 5.3. Обработка ошибок через try...catch

Ошибки при использовании await можно перехватывать через `try...catch`.

**Пример:**

```javascript
async function getData() {
  try {
    const response = await fetch('https://example.com/data');
    if (!response.ok) throw new Error('Ошибка загрузки');
    const data = await response.json();
    console.log(data);
  } catch (err) {
    console.error('Произошла ошибка:', err.message);
  }
}
```

### 5.4. Совмещение await и Promise.all

Если нужно запустить несколько асинхронных задач параллельно — лучше использовать `Promise.all`, даже внутри async.

**Пример:**

```javascript
async function loadAll() {
  const [res1, res2] = await Promise.all([
    fetch('/data1.json'),
    fetch('/data2.json')
  ]);

  const data1 = await res1.json();
  const data2 = await res2.json();

  console.log(data1, data2);
}
```

Все запросы начнут выполняться одновременно, а не последовательно.