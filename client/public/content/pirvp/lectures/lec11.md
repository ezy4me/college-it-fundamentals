# Лекция №11. Архитектура веб-приложений и REST API

---

## 1. Архитектура веб-приложений

Веб-приложения сегодня строятся по определённым архитектурным принципам, которые позволяют разделять ответственность между клиентом и сервером, обеспечивать масштабируемость и гибкость разработки. В этом разделе рассматриваются клиент-серверная архитектура и концепция Single Page Application (SPA), чтобы понимать, как взаимодействуют различные части современного веб-приложения.

---

### 1.1. Клиент-серверная архитектура

> **Клиент-серверная архитектура** — подход, при котором приложение разделяется на два компонента: клиент (интерфейс пользователя) и сервер (логика и данные).

- **Клиент** — компонент, с которым взаимодействует пользователь: веб-браузер, мобильное или десктопное приложение.  
- **Сервер** — компонент, который обрабатывает запросы клиента, выполняет бизнес-логику и управляет хранением данных.

**Пример:**  
1. Пользователь открывает страницу интернет-магазина.  
2. Браузер отправляет запрос на сервер: «покажи список товаров».  
3. Сервер извлекает данные из базы и возвращает их в формате JSON.  
4. Клиент отображает данные пользователю.

**Преимущества клиент-серверной архитектуры:**  
- Разделение ответственности между клиентом и сервером.  
- Возможность независимой разработки фронтенда и бэкенда.  
- Простота масштабирования отдельных компонентов приложения.

![Клиент-серверная архитектура](https://cithub.ru/api/files/pirvp_lec_11_11_1.png)

---

### 1.2. Single Page Application (SPA)

> **Single Page Application (SPA)** — веб-приложение, которое загружается как одна страница и динамически обновляет контент без полной перезагрузки.

- SPA использует API-запросы к серверу для получения данных и обновления интерфейса.  
- Пользовательский интерфейс изменяется динамически, что обеспечивает более плавный и быстрый пользовательский опыт.

**Примеры SPA:**  
- Gmail — обновление почты без перезагрузки.  
- Trello — мгновенное отображение изменений задач.  
- Netflix — динамическая подгрузка контента при навигации.

**Особенности SPA:**  
- Подгружается только необходимый контент.  
- Обновление интерфейса без полной перезагрузки страницы.  
- Используются современные JavaScript-фреймворки: React, Vue, Angular.

--- 

## 2. Application Programming Interface (API)

Современные веб-приложения редко ограничиваются работой внутри одного сервера или браузера. Для взаимодействия между клиентом и сервером используют API.

> **API (Application Programming Interface)** — набор правил и методов, с помощью которых одна программа может обращаться к функционалу другой; позволяет создавать гибкие приложения, где фронтенд и бэкенд могут развиваться независимо.

---

### 2.1. Принцип работы API

Когда мы говорим об API, мы имеем в виду интерфейс, который позволяет разным программным компонентам общаться друг с другом. В веб-разработке API связывает клиентскую часть приложения (браузер, мобильное приложение) с серверной частью, обеспечивая обмен данными.

Принцип работы API можно представить как диалог: клиент задаёт вопрос, сервер отвечает на него. Например, браузер хочет получить список товаров в интернет-магазине. Для этого он отправляет запрос на определённый адрес сервера.

Сервер получает запрос, обрабатывает его, получает данные из базы, формирует ответ и возвращает его клиенту. Клиент, получив ответ, отображает информацию на странице.

В большинстве современных приложений запросы и ответы передаются в формате **JSON**.

> **JSON** — текстовый формат для передачи структурированных данных, удобный как для человека, так и для программ.

Рассмотрим пример: клиент отправляет `GET`-запрос на адрес `/api/items`, чтобы получить список товаров.  
Сервер получает запрос, ищет все товары в базе данных и возвращает их в виде JSON:

```json
[
  { "id": 1, "name": "Футболка", "price": 1000 },
  { "id": 2, "name": "Штаны", "price": 1500 }
]
```

Здесь важно понимать, что клиент не знает, как устроена база данных или как сервер получает данные. Ему важно только то, что по конкретному запросу приходит предсказуемый ответ.

---

### 2.2. Форматы передачи данных

При обмене информацией через API сервер и клиент используют различные форматы данных, которые определяют, как информация кодируется и передаётся.

> **JSON (JavaScript Object Notation)** — текстовый формат для передачи структурированных данных, удобный как для человека, так и для программ.

**Пример JSON с товарами:**
```json
[
  { "id": 1, "name": "Футболка", "price": 1000 },
  { "id": 2, "name": "Штаны", "price": 1500 }
]
```

> **XML (eXtensible Markup Language)** — текстовый формат с тегами, похожими на HTML; используется в некоторых старых сервисах и интеграциях.

**Пример XML с теми же товарами:**
```xml
<items>
  <item>
    <id>1</id>
    <name>Футболка</name>
    <price>1000</price>
  </item>
  <item>
    <id>2</id>
    <name>Штаны</name>
    <price>1500</price>
  </item>
</items>
```

> **Plain Text** — простой текст без структуры; используется для передачи логов, сообщений или данных, не требующих форматирования.

**Пример:**
```
1. Футболка - 1000
2. Штаны - 1500
```

**Важно понимать:**  
- JSON стал стандартом современных веб-приложений из-за простоты и гибкости.  
- Выбор формата зависит от требований системы, но клиент и сервер должны договориться о формате и строго его соблюдать.

---

## 3. REST API

Современные веб-приложения чаще всего используют архитектурный стиль **REST** (Representational State Transfer) для взаимодействия между клиентом и сервером. REST определяет набор принципов, которые делают API предсказуемым, понятным и независимым от платформы.

> **REST API** — архитектурный стиль, при котором сервер предоставляет ресурсы, а клиент обращается к ним через стандартные HTTP-запросы, получая их текущее состояние.

Идея REST проста: благодаря чёткому разделению и использованию стандартных протоколов клиент и сервер могут развиваться независимо, а разработка становится более модульной.

![Модель REST API](https://cithub.ru/api/files/pirvp_lec_11_3_1.png)

### 3.1. Принципы REST API

REST API строится на нескольких ключевых принципах, обеспечивающих его эффективность, удобство и масштабируемость.

1. **Клиент-серверная архитектура**  

Чёткое разделение между клиентом и сервером: клиент запрашивает данные, сервер их предоставляет. Это позволяет независимую разработку фронтенда и бэкенда, упрощает масштабирование и повышает гибкость.  

Пример: браузер отправляет запрос на `/api/items`, сервер возвращает список товаров. Клиент не знает, как сервер хранит данные — важно получить предсказуемый ответ.

2. **Отсутствие состояния (stateless)**  

Каждый запрос от клиента обрабатывается независимо от предыдущих. Сервер не хранит информацию о состоянии клиента между запросами. Это упрощает обработку и повышает отказоустойчивость.  

Пример: два последовательных запроса обрабатываются сервером отдельно, с полной информацией в каждом.

3. **Кеширование**  

Ответы сервера могут кешироваться для снижения нагрузки и ускорения работы. REST поддерживает стандартные HTTP-механизмы: `Cache-Control`, `ETag`.  

Пример: если список товаров редко меняется, браузер может использовать локальную копию до истечения срока кеша.

4. **Единообразие интерфейса (Uniform Interface)**  

Все ресурсы имеют предсказуемые URL и управляются стандартными HTTP-методами: `GET`, `POST`, `PUT`, `DELETE`. Данные передаются в структурированных форматах (JSON, XML).  

Пример:  
- `GET /api/items` — получить список товаров  
- `POST /api/items` — создать новый товар  
- `PUT /api/items/1` — обновить товар с id 1  
- `DELETE /api/items/1` — удалить товар с id 1

5. **Система уровней (Layered System)**  

Архитектура может включать промежуточные слои: балансировщики, прокси, аутентификацию. Клиент не видит внутреннюю структуру — всё скрыто за единым интерфейсом.  
Пример: запрос проходит через несколько серверов, но клиенту это прозрачно.

---

### 3.2. Компоненты REST API

REST API строится на нескольких ключевых компонентах, определяющих его поведение и структуру.

### 3.2.1. Ресурсы и их идентификация

> **Ресурс** — объект или сущность, доступная через API (пользователь, товар, заказ).

Каждый ресурс идентифицируется уникальным **URI** (Uniform Resource Identifier).

**Особенности URI:**  
- Должен быть предсказуемым и единообразным.  
- Не содержит глаголов — описывает сущность, а не действие.  
- Может включать параметры для фильтрации и сортировки.

**Примеры URI:**  
- `/api/users` — коллекция всех пользователей  
- `/api/users/42` — конкретный пользователь с ID 42  
- `/api/orders?status=completed` — заказы со статусом «выполнен»

> **Примечание:** URI вроде `/api/users/42/profile` технически допустим, но нарушает принцип «плоских» URI. Лучше использовать параметры: `/api/users/42?include=profile`.

---

### 3.2.2. HTTP-методы (CRUD-операции)

Для работы с ресурсами используются стандартные HTTP-методы:

- `GET` — получение данных  
- `POST` — создание нового ресурса  
- `PUT` — полное обновление ресурса  
- `PATCH` — частичное обновление ресурса  
- `DELETE` — удаление ресурса

**Примеры операций:**  
- `GET /api/books/123` — получить информацию о книге  
- `DELETE /api/comments/456` — удалить комментарий

**Таблица 1 – HTTP-методы и их свойства**

| Метод   | Идемпотентность* | Безопасность** | Пример использования        |
|--------|------------------|----------------|-----------------------------|
| GET    | Да               | Да             | Получение данных            |
| POST   | Нет              | Нет            | Создание нового ресурса     |
| PUT    | Да               | Нет            | Полное обновление ресурса   |
| PATCH  | Нет              | Нет            | Частичное обновление ресурса|
| DELETE | Да               | Нет            | Удаление ресурса            |

> *Идемпотентность — повторный запрос даёт тот же результат.  
> **Безопасность — метод не изменяет состояние ресурса.

---

### 3.2.3. Представления ресурсов

Клиент и сервер обмениваются данными в согласованном формате.

> **JSON** — стандарт для современных API:  
```json
{
  "id": 123,
  "title": "REST API Design",
  "author": "John Doe",
  "year": 2009
}
```

> **XML** — используется в legacy-системах:  
```xml
<book>
  <id>123</id>
  <title>REST API Design</title>
  <author>John Doe</author>
  <year>2009</year>
</book>
```

Формат согласуется через заголовки:  
- `Accept` — ожидаемый формат ответа  
- `Content-Type` — формат данных в теле запроса

---

### 3.2.4. Заголовки HTTP

Заголовки передают метаинформацию о запросе или ответе.

**Популярные заголовки:**  
- `Authorization` — токен аутентификации  
- `Cache-Control` — управление кешированием  
- `ETag` — идентификатор версии ресурса

**Пример запроса:**  
```http
GET /api/users/42 HTTP/1.1
Host: api.example.com
Accept: application/json
Authorization: Bearer xyz123
Cache-Control: no-cache
```

---

### 3.2.5. Коды состояния HTTP

Коды позволяют клиенту понять результат запроса.

**Группы кодов:**  

**1xx — Информационные**  
- `100 Continue` — сервер готов принять тело запроса  
- `101 Switching Protocols` — подтверждение переключения протокола (например, на WebSocket)

**2xx — Успех**  
- `200 OK` — успешный запрос  
- `201 Created` — ресурс создан  
- `204 No Content` — успешно, без тела ответа  

**3xx — Перенаправления**  
- `304 Not Modified` — используйте кеш  

**4xx — Ошибки клиента**  
- `400 Bad Request` — неверный синтаксис  
- `401 Unauthorized` — требуется авторизация  
- `403 Forbidden` — доступ запрещён  
- `404 Not Found` — ресурс не найден  
- `429 Too Many Requests` — превышен лимит  

**5xx — Ошибки сервера**  
- `500 Internal Server Error` — общая ошибка  
- `503 Service Unavailable` — сервис недоступен  


**Пример ответа с ошибкой:**  
```http
HTTP/1.1 404 Not Found
Content-Type: application/json
```
```json
{
  "error": "User not found",
  "message": "The requested user does not exist"
}
```

---

### 3.2.6. Тело запроса и ответа

**Тело запроса** содержит данные, отправляемые серверу (обычно JSON).  
**Пример запроса на создание книги:**
```http
POST /api/books HTTP/1.1
Content-Type: application/json
```
```json
{
  "title": "API Design Patterns",
  "year": 2021
}
```

**Тело ответа** содержит данные от сервера.  
**Пример успешного ответа:**
```http
HTTP/1.1 201 Created
Location: /api/books/789
Content-Type: application/json
```
```json
{
  "id": 789,
  "title": "API Design Patterns",
  "year": 2021,
  "created_at": "2023-10-01T12:00:00Z"
}
```

**Пример работы с пользователями:**

Создание пользователя:
```http
POST /api/users HTTP/1.1
Content-Type: application/json
```
```json
{
  "name": "Алексей Петров",
  "email": "alex@example.com"
}
```

Ответ сервера:
```http
HTTP/1.1 201 Created
Location: /api/users/101
Content-Type: application/json
```
```json
{
  "id": 101,
  "name": "Алексей Петров",
  "email": "alex@example.com",
  "status": "active"
}
```

Ошибочный запрос:
```http
GET /api/users/999 HTTP/1.1
Accept: application/json
```

Ответ сервера:
```http
HTTP/1.1 404 Not Found
Content-Type: application/json
```
```json
{
  "error": "User not found",
  "message": "The requested user does not exist"
}
```

---

### 3.2.7. Лучшие практики

При проектировании REST API рекомендуется следовать следующим правилам:

1. **Использовать множественное число в URI**  

Пример: `/users`, `/users/42`. Не рекомендуется: `/user/42`.

2. **Разделять ресурсы и действия**  

URI описывает сущность, а не действие.  
Правильно: `POST /orders`  
Неправильно: `POST /createOrder`

3. **Использовать пагинацию и фильтры**  

Пример:  
- `/users?page=2&limit=50` — пагинация  
- `/orders?status=completed` — фильтрация

4. **Использовать корректные HTTP-методы**  

- `GET` — получение  
- `POST` — создание  
- `PUT`/`PATCH` — обновление  
- `DELETE` — удаление

5. **Использовать плоские и читаемые URI**  

Вместо: `/api/users/42/profile/address/street`  
Лучше:  
- `/api/users/42`  
- `/api/addresses?user_id=42`  
Цель — улучшить читаемость, предсказуемость и расширяемость.

6. **Документировать API**  

Использовать спецификации OpenAPI/Swagger для описания эндпоинтов, форматов и ошибок.

--- 

## 4. Инструменты для работы с REST API

При разработке веб-приложений важной частью является взаимодействие с REST API. Для эффективной работы с API разработчики используют различные инструменты, позволяющие документировать, тестировать и отправлять запросы. Это помогает быстрее находить ошибки, проверять корректность работы серверной части и облегчает командную работу.

### 4.1. Документирование API

> **Документация API** — подробное описание всех доступных эндпоинтов, форматов данных, параметров запросов и возможных ошибок.

Хорошо оформленная документация позволяет разработчикам быстро понять структуру API и правильно использовать его в приложении.

- **Swagger / OpenAPI** — популярный стандарт для описания REST API; позволяет автоматически генерировать интерактивную документацию и клиентский код на разных языках программирования.

Документирование особенно важно для командной разработки, где фронтенд и бэкенд разрабатываются параллельно, а также для внешних пользователей API.

![Swagger / OpenAPI](https://cithub.ru/api/files/pirvp_lec_11_41_1.png)

---

### 4.2. Клиенты для отправки запросов

Для тестирования и работы с API на этапе разработки используют специальные клиенты, которые упрощают создание запросов и анализ ответов сервера.

- **Postman** — графический клиент, позволяющий отправлять запросы, сохранять коллекции, настраивать переменные окружения и автоматизировать тесты.  
- **Insomnia** — удобный GUI-клиент для работы с REST и GraphQL API; поддерживает сложные сценарии запросов и аутентификацию.  
- **curl** — утилита командной строки для отправки HTTP-запросов; удобна для скриптов и быстрой проверки работы API без графического интерфейса.

Использование таких клиентов позволяет разработчикам проверить работу эндпоинтов до интеграции их в приложение, а также протестировать различные варианты запросов.

![Postman](https://cithub.ru/api/files/pirvp_lec_11_42_1.png)

---

### 4.3. Локальное тестирование API

> **Локальное тестирование API** — подход, при котором клиентская часть приложения разрабатывается и тестируется без готового сервера, с использованием имитации (моков) ответов API.

- **Mock-сервисы** (например, `json-server`, `Mockoon`) позволяют создавать локальные REST API с заранее заданными данными.  
- Это даёт возможность тестировать обработку ошибок, проверять корректность работы фронтенда и моделировать разные сценарии взаимодействия с сервером.

Локальное тестирование ускоряет процесс разработки, особенно в командах, где фронтенд и бэкенд разрабатываются параллельно.

