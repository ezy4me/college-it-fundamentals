# Лекция №13. Основы React: JSX, компоненты, state и props

## 1. Введение в React

> **React** — библиотека JavaScript для построения пользовательских интерфейсов; упрощает создание динамичных веб-приложений за счёт декларативного подхода и компонентной структуры.

Компоненты в React — это самостоятельные части интерфейса, которые могут хранить состояние, получать данные через свойства (props) и взаимодействовать с другими компонентами. Такой подход позволяет создавать повторно используемые и легко поддерживаемые элементы интерфейса.

Ключевая особенность React — **виртуальный DOM**. Вместо прямого изменения DOM браузера React сначала обновляет виртуальную копию структуры страницы, а затем применяет минимальные изменения к реальному DOM. Это повышает производительность и делает работу с интерфейсом более предсказуемой.

**Пример:**  
Если нужно вывести список пользователей, создаётся компонент `<UserList>`, внутри которого — компоненты `<UserCard>` для каждого пользователя. Изменение данных автоматически обновит только те компоненты, которые изменились, без полной перерисовки страницы.

### 1.1. Понятие библиотеки React

React — библиотека, а не фреймворк. Это означает, что она решает конкретные задачи: построение интерфейса и управление состоянием компонентов, но не навязывает архитектуру всего приложения.

**Основные понятия:**  
- **Компоненты** — строительные блоки интерфейса; каждый описывает, как должна выглядеть часть страницы и как она реагирует на изменения данных.  
- **Props (свойства)** — способ передавать данные в компонент извне; позволяют делать компоненты переиспользуемыми.  
- **State (состояние)** — внутренние данные компонента; их изменение автоматически вызывает обновление интерфейса.  
- **Виртуальный DOM** — механизм, позволяющий обновлять только изменившиеся элементы страницы, повышая производительность.

**Пример компонента:**

```jsx
function Greeting(props) {
  return <h1>Привет, {props.name}!</h1>;
}

// Использование компонента
<Greeting name="Алексей" />
```
Здесь `<Greeting>` — компонент, а `props.name` передаёт в него имя. Любое изменение `props.name` автоматически обновит отображение.

### 1.2. Отличия от работы с чистым JavaScript

React отличается от традиционного JavaScript в организации и управлении интерфейсом:

1. **Декларативный подход**  

Вместо ручного обновления DOM описывается, каким должен быть интерфейс, а React сам управляет изменениями.  
```javascript
// Чистый JS
document.getElementById('root').innerHTML = '<h1>Привет!</h1>';

// React
function Greeting() {
    return <h1>Привет!</h1>;
}
```

2. **Компонентная структура**  

Интерфейс разбивается на переиспользуемые компоненты, что упрощает поддержку и тестирование.

3. **Автоматическое обновление данных**  

Изменение состояния (`state`) сразу отражается в интерфейсе без ручного вмешательства в DOM.

4. **Оптимизация через виртуальный DOM**  

React минимизирует операции с реальным DOM, особенно эффективно на больших и динамичных страницах.

### 1.3. Создание проекта React с Vite

Современные React-проекты чаще всего создаются с помощью **Vite** — инструмента, который быстро собирает проект и обеспечивает мгновенное обновление в браузере.

**Создание проекта:**  
Убедитесь, что установлен Node.js, затем выполните в терминале:
```bash
npm create vite@latest my-react-app
```

Во время установки выберите:  
- Framework: **React**  
- Variant: **JavaScript** или **TypeScript**

После завершения:

```bash
cd my-react-app
npm install
npm run dev
```
![Вомбат](https://cithub.ru/api/files/вомбат.jpg)

Откройте указанный адрес (например, `http://localhost:5173/`) — вы увидите стартовую страницу Vite.

![Вомбат](https://cithub.ru/api/files/вомбат.jpg)

![Вомбат](https://cithub.ru/api/files/вомбат.jpg)

### 1.4. Структура проекта

После создания проект имеет следующую структуру:

```
my-react-app/
├─ node_modules/          # зависимости проекта
├─ public/                # статические файлы
│  └─ vite.svg            # пример логотипа
├─ src/                   # исходный код приложения
│  ├─ assets/             # изображения, шрифты и т.д.
│  ├─ App.jsx             # главный компонент приложения
│  ├─ App.css             # стили для App.jsx
│  ├─ index.css           # глобальные стили
│  └─ main.jsx            # точка входа React
├─ .gitignore             # исключения для Git
├─ package.json           # зависимости и скрипты
├─ vite.config.js         # настройки сборщика Vite
├─ eslint.config.js       # настройки линтера
└─ README.md              # описание проекта
```

**Корневые файлы проекта:**  
- `package.json` — зависимости и скрипты (`dev`, `build`, `lint`)  
- `vite.config.js` — настройки сборки и плагины  
- `index.html` — главная HTML-страница, контейнер для React  
- `.gitignore` — исключает `node_modules` и временные файлы из Git  
- `eslint.config.js` — настройки линтера

**Папка `src`:**  
- `main.jsx` — точка входа; рендерит корневой компонент `App` в DOM  
- `App.jsx` — главный компонент приложения  
- `App.css` — стили для `App.jsx`  
- `assets/` — статические файлы (изображения, шрифты)  
- `index.css` — глобальные стили (сброс CSS, базовые шрифты)

**Папка `public`:**  
- Файлы, доступные напрямую в браузере (логотипы, `robots.txt`, favicon)  
- Используется для статики, которая не обрабатывается сборщиком

**Особенности Vite:**  
- `node_modules` — зависимости, установленные через `npm install`  
- `README.md` — описание проекта и инструкции по запуску

--- 

Вот ваш фрагмент, оформленный **строго в вашем стиле** — с правильной иерархией заголовков, определениями в одну строку через `>`, списками с отступами, без `####`, и с таблицей только там, где она была в исходнике:

---

## 2. JSX

> **JSX (JavaScript XML)** — расширение синтаксиса JavaScript, позволяющее описывать интерфейс с помощью тегов и атрибутов, похожих на HTML; делает код компонентов более наглядным и объединяет логику с разметкой.

**Ключевые моменты:**  
- JSX компилируется в обычные вызовы `React.createElement`, поэтому браузер напрямую его не понимает.  
- Позволяет вставлять переменные, выражения и функции внутрь разметки.  
- Используется для создания компонентов React, которые затем рендерятся в DOM.

### 2.1. Синтаксис JSX и его назначение

JSX позволяет описывать интерфейс с помощью тегов, атрибутов и JavaScript-выражений.

**Пример базового компонента:**
```jsx
function Greeting() {
  return <h1>Привет, мир!</h1>;
}
```
Здесь `<h1>` — JSX-элемент, описывающий внешний вид компонента.

**Особенности синтаксиса:**  
- Каждый компонент должен возвращать **один корневой элемент**.  
- Для группировки нескольких элементов используют `<div>` или **React Fragment**:  
  ```jsx
  function App() {
    return (
      <>
        <h1>Привет!</h1>
        <p>Добро пожаловать в React</p>
      </>
    );
  }
  ```

> **`<> ... </>`** — короткая запись для `React.Fragment`; позволяет группировать элементы без добавления лишнего `<div>` в DOM.

---

### 2.2. Вставка переменных и выражений

В JSX можно использовать любые JavaScript-выражения внутри фигурных скобок `{}`.

**Пример с переменной из props:**
```jsx
function UserGreeting(props) {
  const name = props.name;
  return <h2>Привет, {name}!</h2>;
}
```

**Особенности:**  
- Можно вставлять строки, числа, результаты функций, массивы (для рендеринга списков).  
- Условия реализуются через **тернарный оператор**:  

```jsx
function StatusMessage({ isOnline }) {
    return <p>{isOnline ? "В сети" : "Не в сети"}</p>;
}
```

- Можно вызывать функции прямо в JSX:  
```jsx
function formatName(user) {
    return user.firstName + " " + user.lastName;
}

function Welcome(props) {
    return <h1>Привет, {formatName(props.user)}!</h1>;
}
```

---

### 2.3. Отличия JSX от HTML

JSX похож на HTML, но имеет важные отличия.

**Атрибуты:**  
Некоторые HTML-атрибуты имеют другие названия в JSX:

| HTML   | JSX        | Пример                              |
|--------|------------|-------------------------------------|
| class  | className  | `<div className="container"></div>` |
| for    | htmlFor    | `<label htmlFor="nameInput">Имя:</label>` |

**Стили:**  
В JSX стили задаются объектом с **camelCase**-свойствами:
```jsx
const style = { color: "red", fontSize: "20px" };
<p style={style}>Красный текст</p>
```

**Закрывающие теги:**  
Все теги в JSX **должны быть закрыты**, даже самозакрывающиеся:
```jsx
<img src="logo.png" />
<input />
```

--- 

## 3. Компоненты

> **Компоненты** — строительные блоки интерфейса в React; каждый описывает часть UI, может иметь внутреннее состояние и получать данные через props.

Использование компонентов позволяет создавать повторно используемые и легко поддерживаемые элементы интерфейса.

### 3.1. Функциональные компоненты

> **Функциональный компонент** — обычная JavaScript-функция, возвращающая JSX-разметку; является современным стандартом в React.

**Пример базового компонента:**
```jsx
function Greeting() {
  return <h1>Привет, мир!</h1>;
}

// Использование компонента
function App() {
  return (
    <div>
      <Greeting />
    </div>
  );
}

export default App;
```

**Пояснения:**  
- Функция `Greeting` возвращает JSX-элемент `<h1>`.  
- Компонент `<Greeting />` можно использовать внутри других компонентов.

---

### 3.2. Иерархия и композиция компонентов

Компоненты могут содержать другие компоненты, формируя иерархию и позволяя собирать сложные интерфейсы из простых частей.

**Пример:**
```jsx
function UserCard({ name, age }) {
  return (
    <div>
      <h2>{name}</h2>
      <p>Возраст: {age}</p>
    </div>
  );
}

function App() {
  return (
    <div>
      <UserCard name="Алексей" age={25} />
      <UserCard name="Мария" age={30} />
    </div>
  );
}
```

**Пояснения:**  
- `App` — родительский компонент, `UserCard` — дочерний.  
- Каждый `UserCard` получает данные через `props`.  
- Такой подход делает код модульным и легко расширяемым.

---

### 3.3. Повторное использование компонентов

Компоненты можно использовать многократно с разными данными, что снижает дублирование кода.

**Пример универсального компонента:**
```jsx
function Button({ text, onClick }) {
  return <button onClick={onClick}>{text}</button>;
}

function App() {
  return (
    <div>
      <Button text="Сохранить" onClick={() => alert("Сохранено!")} />
      <Button text="Удалить" onClick={() => alert("Удалено!")} />
    </div>
  );
}
```

**Пояснения:**  
- Компонент `Button` подходит для любых кнопок с разными текстами и действиями.  
- Props `text` и `onClick` делают компонент гибким и переиспользуемым.

--- 

## 4. Props

> **Props (свойства)** — механизм передачи данных из родительского компонента в дочерний; делают компоненты гибкими и переиспользуемыми, при этом остаются неизменяемыми (только для чтения) внутри компонента.

### 4.1. Передача данных в компонент

Props передаются как атрибуты JSX.

**Пример:**
```jsx
function Greeting({ name }) {
  return <h1>Привет, {name}!</h1>;
}

function App() {
  return (
    <div>
      <Greeting name="Алексей" />
      <Greeting name="Мария" />
    </div>
  );
}

export default App;
```

Здесь компонент `Greeting` используется с разными значениями `props`, что позволяет переиспользовать один и тот же компонент с разными данными.

---

### 4.2. Использование и деструктуризация props

Props можно получать как объект или через деструктуризацию.

**Через объект `props`:**
```jsx
function UserCard(props) {
  return (
    <div>
      <h2>{props.name}</h2>
      <p>Возраст: {props.age}</p>
    </div>
  );
}
```

**Через деструктуризацию (рекомендуется):**
```jsx
function UserCard({ name, age }) {
  return (
    <div>
      <h2>{name}</h2>
      <p>Возраст: {age}</p>
    </div>
  );
}
```

---

### 4.3. Пример: карточка с данными пользователя

Компонент `UserCard` получает объект пользователя через `props` и отображает его данные:

```jsx
function UserCard({ user }) {
  return (
    <div className="user-card">
      <h2>{user.name}</h2>
      <p>Возраст: {user.age}</p>
      <p>Email: {user.email}</p>
    </div>
  );
}

function App() {
  const users = [
    { name: "Алексей", age: 25, email: "alex@mail.com" },
    { name: "Мария", age: 30, email: "maria@mail.com" },
  ];

  return (
    <div>
      {users.map((user, index) => (
        <UserCard key={index} user={user} />
      ))}
    </div>
  );
}

export default App;
```

**Пояснения:**  
- `UserCard` получает все данные пользователя через `user`.  
- `App` рендерит список пользователей.  
- Атрибут `key` необходим React для эффективного обновления списков.

--- 

## 5. State

> **State (состояние)** — внутренние данные компонента, которые могут изменяться со временем; в отличие от props, управляется самим компонентом, и его изменение автоматически вызывает перерисовку.

State используется для хранения данных, изменяющихся в процессе работы приложения: состояние формы, счётчик, переключатели и т.д.

### 5.1. Понятие состояния компонента

Каждый компонент может иметь собственное состояние, создаваемое с помощью хука `useState`.

**Пример:**
```jsx
import { useState } from "react";

function Counter() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <h1>Счетчик: {count}</h1>
      <button onClick={() => setCount(count + 1)}>Увеличить</button>
    </div>
  );
}

export default Counter;
```

**Пояснения:**  
- `count` — текущее значение состояния.  
- `setCount` — функция для его изменения.  
- `useState(0)` задаёт начальное значение `0`.  
- При нажатии кнопки значение `count` увеличивается, и React автоматически перерисовывает компонент.

---

### 5.2. Хук useState

> **`useState`** — хук React, возвращающий массив из двух элементов: текущее значение состояния и функцию для его обновления.

Можно хранить любые типы данных: числа, строки, массивы, объекты.

**Пример с объектом:**
```jsx
import { useState } from "react";

function UserInfo() {
  const [user, setUser] = useState({ name: "Алексей", age: 25 });

  return (
    <div>
      <p>Имя: {user.name}</p>
      <p>Возраст: {user.age}</p>
      <button onClick={() => setUser({ ...user, age: user.age + 1 })}>
        Добавить год
      </button>
    </div>
  );
}

export default UserInfo;
```

Используется оператор расширения (`...`) для сохранения остальных полей объекта при изменении одного из них.

---

### 5.3. Обновление состояния и перерисовка

React автоматически отслеживает изменения состояния и обновляет интерфейс. При этом:  
- Перерисовывается **только компонент**, в котором изменился `state`.  
- Родительский компонент не пересоздаётся без необходимости.

---

### 5.4. Отличие state от props

| Свойство       | props                     | state                     |
|----------------|---------------------------|---------------------------|
| Кто управляет  | Родитель                  | Сам компонент             |
| Можно изменять?| Нет                       | Да                        |
| Цель           | Передача данных в компонент | Хранение внутреннего состояния |

**Пример совместного использования:**
```jsx
function Greeting({ initialName }) {
  const [name, setName] = useState(initialName);

  return (
    <div>
      <h1>Привет, {name}!</h1>
      <button onClick={() => setName("Мария")}>Сменить имя</button>
    </div>
  );
}

export default Greeting;
```

Здесь значение из `props` (`initialName`) используется как начальное значение `state`, а дальше компонент сам управляет своим состоянием.

---

## 6. Обработка событий

> **Обработка событий в React** — механизм реагирования на действия пользователя; работает аналогично HTML, но с рядом отличий.

**Основные отличия от HTML:**  
- События записываются в **camelCase** (`onClick`, `onChange`).  
- Обработчики передаются как **функции**, а не как строки.  
- Данные можно передавать в родительские компоненты через **функции-колбэки**.

### 6.1. Основные события

Некоторые часто используемые события в React:

| Событие      | Использование                          |
|--------------|----------------------------------------|
| `onClick`    | Клик по кнопке или элементу            |
| `onChange`   | Изменение значения `input`, `textarea`, `select` |
| `onSubmit`   | Отправка формы                         |
| `onMouseEnter` | Наведение курсора мыши               |
| `onKeyDown`  | Нажатие клавиши                        |

**Пример `onClick`:**
```jsx
function ClickButton() {
  const handleClick = () => {
    alert("Вы кликнули!");
  };

  return <button onClick={handleClick}>Нажми меня</button>;
}

export default ClickButton;
```

---

### 6.2. Работа с функциями-обработчиками

Функции-обработчики можно определять внутри компонента или получать из родителя через props.

**Пример с передачей параметра:**
```jsx
function GreetButton({ name }) {
  const greet = (userName) => {
    alert(`Привет, ${userName}!`);
  };

  return <button onClick={() => greet(name)}>Поздороваться</button>;
}

export default GreetButton;
```

Здесь используется стрелочная функция для передачи аргумента в обработчик.

---

### 6.3. Передача событий в дочерние компоненты

Дочерний компонент может уведомлять родителя о событии, вызывая переданную через props функцию.

**Пример:**
```jsx
function Child({ onNotify }) {
  return <button onClick={() => onNotify("Привет из дочернего")}>Отправить</button>;
}

function Parent() {
  const handleNotification = (message) => {
    alert(message);
  };

  return <Child onNotify={handleNotification} />;
}

export default Parent;
```

Дочерний компонент вызывает функцию родителя через `props`, передавая данные о событии.

--- 
