# Лекция №3. Основы CSS: стилизация и каскадность

---

## 1. Введение в CSS

> **CSS (Cascading Style Sheets)** — это каскадные таблицы стилей, язык, с помощью которого описывается внешний вид HTML-элементов на веб-странице.  

Если HTML — это **структура** (что на странице), то CSS — это **внешний вид** (как это выглядит):  

- Расположение элементов  
- Цвета и шрифты  
- Отступы и выравнивание  
- Размеры и формы  
- Анимации и переходы  

**Пример:**  
HTML добавляет кнопку, а CSS делает её круглой, розовой и центрированной.  

---

### 1.1. Что такое CSS

> CSS определяет **правила стилей**, которые говорят браузеру, как отображать HTML-элементы.  

Эти правила можно применять:  

- К отдельным тегам  
- К классам и идентификаторам  
- К целым группам элементов  

С помощью CSS мы можем, например:  

- Установить фон сайта в светло-серый  
- Сделать заголовок крупным и жирным  
- Разместить карточки товаров в сетку  

**Простой пример:**

```html
<h1>Заголовок</h1>

<style>
  h1 {
    color: darkblue;
    font-size: 32px;
  }
</style>
```

---


### 1.2. Роль CSS в разработке веб-интерфейсов

CSS решает три ключевые задачи:  

**1. Отделение контента от оформления.**

Логика (HTML) и стиль (CSS) находятся в разных файлах — это облегчает сопровождение кода.  

**2. Повторное использование и масштабирование.**

Один CSS-файл может задавать стиль для сотен страниц — экономия времени и ресурсов.  

**3. Гибкость в оформлении и адаптивность.**

CSS позволяет менять стили под разные устройства, экраны и состояния.  

Один и тот же CSS позволяет:  

- На десктопе показывать сетку из 4 карточек  
- На телефоне — одну карточку в ряд  

---

## 2. Синтаксис и структура CSS

CSS основан на наборе правил, каждое из которых описывает, какие элементы должны быть стилизованы и как именно.  

---

### 2.1. Общее устройство CSS-правила

Каждое правило состоит из двух основных частей:  

- **Селектор** — указывает, к каким элементам применяется стиль.  
- **Блок деклараций** — содержит одно или несколько свойств с соответствующими значениями.  

**Пример:**

```css
p {
  color: black;
  font-size: 16px;
}
```

**Разбор примера:**

- `p` — **селектор** (выбирает все теги `<p>`).  
- `{ color: black; font-size: 16px; }` — **блок деклараций**.  
- `color` и `font-size` — **свойства**.  
- `black` и `16px` — **значения**.  

Каждая декларация заканчивается точкой с запятой `;`, а блок оборачивается в фигурные скобки `{}`.  

---

### 2.2. Комментарии в CSS

**Комментарии** помогают объяснять код и игнорируются браузером.  
Они не отображаются на странице и не влияют на работу стилей.  

**Пример:**

```css
/* Это комментарий */

h1 {
  color: navy; /* Заголовок будет тёмно-синим */
}
```

Комментарии полезны при работе в команде или при возвращении к старому коду.  

---

### 2.3. Единицы измерения

**CSS использует разные единицы измерения для задания размеров, отступов и других параметров.**

| **Единица** | **Что означает** | **Пример** | |
|-------------|-----------------|------------|---|
| `px` | Пиксели | `width: 200px;` | |
| `%` | Проценты от родителя | `width: 50%;` | |
| `em` | Относительно текущего размера шрифта | `font-size: 1.2em;` | |
| `rem` | Относительно корневого шрифта (`<html>`) | `font-size: 1.5rem;` | |
| `vh / vw` | Проценты от высоты / ширины окна | `height: 100vh;` | |
| `fr` | Фракции в CSS Grid | `grid-template-columns: 1fr 2fr;` | |

---

## 3. Селекторы

**Селекторы** в CSS определяют, к каким HTML-элементам будет применяться стиль.  
Они бывают **простыми** и **составными**, а также могут использоваться в сочетании с **псевдоклассами** и **псевдоэлементами**.

___

### 3.1. Базовые селекторы

**1.По тегу:** 

Применяется ко всем элементам с указанным тегом.  

**Пример:**  
```css
h1 { 
    color: darkgreen; 
}
```

- Все заголовки `<h1>` будут зелёными.  

**2. По классу:**  

Применяется ко всем элементам с определённым классом.  
Перед именем класса ставится точка `.`

**Пример:**  
```css
.card { 
    border: 1px solid #ccc; 
}
```

- Любой элемент с `class="card"` будет иметь границу.  

---

**3. По id:**  

Применяется к элементу с конкретным id.  
Перед именем ставится решётка `#`

**Пример:**  
```css
#header { 
    background-color: #f5f5f5; 
}
```

> **Важно:** id должен быть уникальным на странице, поэтому селектор `#id` применяется только к одному элементу.

---

### 3.2. Комбинированные селекторы

Комбинированные селекторы позволяют находить элементы в определённом контексте, опираясь на их положение в DOM-дереве.  
Они помогают писать более точные стили, особенно в больших проектах.  

**Потомок (селектор через пробел):**

```css
article p {
  color: #333;
}
```

Применяется ко всем тегам `<p>`, которые находятся внутри тега `<article>` — не важно, как глубоко.  

**Пример HTML:**

```html
<article>
  <div>
    <p>Этот параграф изменится.</p>
  </div>
</article>
```

Сработает, даже если между `<article>` и `<p>` находятся другие теги.  

**Дочерний (`>`) — прямой потомок:**

```css
ul > li {
  color: blue;
}
```

Применяется только к тем **непосредственным (прямым) детям** `<ul>`.  

**Пример HTML:**

```html
<ul>
  <li>Синий</li> <!-- применится -->
  <div>
    <li>Не синий</li> <!-- не применится -->
  </div>
</ul>
```

Важно: `>` — это как стрелка «один шаг вниз». Только один уровень вложенности.  

**Соседний (`+`) — ближайший сосед:**

```css
h2 + p {
  font-style: italic;
}
```

Применяется к элементу, который идёт сразу после `<h2>`, на том же уровне вложенности.  

**Пример HTML:**

```html
<h2>Заголовок</h2>
<p>Этот абзац будет курсивным</p>
<p>А этот — нет</p>
```

Важно: между `<h2>` и `<p>` не должно быть других элементов или текстов — иначе не сработает.  

**Обобщённый сосед (`~`) — все следующие соседи:**

```css
h2 ~ p {
  color: gray;
}
```
Применяется ко всем элементам `<p>`, которые идут после `<h2>` и находятся на одном уровне.  

**Пример HTML:**

```html
<h2>Заголовок</h2>
<p>Подсветится</p>
<div>Что-то</div>
<p>Тоже подсветится</p>
```

— Работает, даже если между `<h2>` и `<p>` другие элементы.  

---

### 3.3. Атрибутные селекторы

Атрибутные селекторы позволяют применять стили к элементам на основе наличия определённых HTML-атрибутов или их значений.  
Это особенно полезно при стилизации форм, ссылок, динамически генерируемых компонентов и т.д.  

**Селектор по наличию атрибута:**

```css
[disabled] {
  opacity: 0.5;
}
```

Применяется ко всем элементам, у которых присутствует атрибут `disabled` — независимо от его значения.  

**Селектор по точному значению:**

```css
input[type="text"] {
  background-color: #f9f9f9;
}
```
Стили применяются только к полям `<input>`, у которых `type` строго равен `"text"`.  

**Селектор по началу значения:**

```css
a[href^="https"] {
  color: green;
}
```
Селектор с `^=` находит элементы, у которых значение атрибута начинается с указанной строки.  
Здесь — все ссылки, начинающиеся с `https`.  

**Селектор по окончанию значения:**

```css
a[href$=".pdf"] {
  color: red;
}
```

Селектор с `$=` применяет стили ко всем ссылкам, которые заканчиваются на `.pdf` — удобно для обозначения ссылок на файлы.  

**Селектор по вхождению подстроки:**

```css
a[href*="youtube"] {
  text-decoration: underline;
}
```
Селектор с `*=` находит элементы, в значении атрибута которых встречается указанная строка — в данном случае, `"youtube"`.  

**Когда применять атрибутные селекторы:**

- При стилизации разных типов `input`: `text`, `checkbox`, `radio`  
- Для выделения внешних ссылок, ссылок на файлы, внутренних переходов  
- При работе с автоматически сгенерированной HTML-разметкой  
- Когда добавление классов невозможно или неудобно  

---

### 3.4. Псевдоклассы

Псевдоклассы используются, когда нужно применить стиль к элементу в определённом состоянии или положении на странице — без необходимости менять HTML.  

**Синтаксис:** `элемент:состояние { ... }`  

**1. Стили по состоянию:**  
- `:hover` — когда пользователь наводит курсор  

**Пример:**

```css
a:hover {
  text-decoration: underline;
}
```

Используется для кнопок, ссылок, карточек — подчёркивание, изменение цвета, подсветка.  

- `:focus` — когда элемент в фокусе (например, курсор в поле ввода)  

**Пример:**

```css
input:focus {
  outline: 2px solid blue;
}
```

Улучшает доступность и визуально показывает, куда вводится текст.  

- `:active` — момент нажатия мышью  

**Пример:**

```css
button:active {
  transform: scale(0.98);
}
```
Часто используется для эффекта "нажатой" кнопки.  

**2. Стили по положению:**  
- `:first-child` — если элемент первый среди соседей  

**Пример:**

```css
li:first-child {
  font-weight: bold;
}
```

- `:last-child` — если элемент последний  

**Пример:**

```css
li:last-child {
  color: gray;
}
```

- `:nth-child(n)` — выбор по номеру  

**Пример:**

```css
tr:nth-child(even) {
  background: #f0f0f0;
}
```

Выбирает чётные строки таблицы. Можно также использовать `odd`, `3`, `3n + 1` и т.д.  

- `:not(...)` — исключает элементы из выборки  

**Пример:**

```css
button:not(.primary) {
  background: #ddd;
}
```
Стили применяются ко всем кнопкам, кроме тех, что с классом `.primary`.  

**Когда использовать:**

- Для наведения, фокуса, активации без JavaScript  
- Для стилизации отдельных элементов в списке (первый, последний, чётный и т.д.)  
- Для более чистого CSS без лишних классов  

---

### 3.5. Псевдоэлементы

Псевдоэлементы позволяют стилизовать часть содержимого элемента или вставлять дополнительный контент с помощью CSS — без изменения HTML.  
Они начинаются с двойного двоеточия `::`, но в старых стандартах допустим один `:` — оба варианта работают, но рекомендуется использовать `::`.  

**Псевдоэлементы `::before` и `::after`:**

Оба псевдоэлемента создают виртуальные элементы, которые вставляются внутрь целевого тега:  

- `::before` — вставляется перед содержимым  
- `::after` — вставляется после содержимого  

⚠️ Эти элементы не отображаются без свойства `content`.  

**Пример:**

```css
p::before {
  content: "→ ";
  color: gray;
}

p::after {
  content: " ←";
  color: lightgray;
}
```

**Пример: декоративная иконка перед ссылкой**

```css
a::before {
  content: "🔗";
  margin-right: 4px;
}
```

Это позволяет добавить иконку ко всем ссылкам, не меняя HTML-код.  

**Пример: подчёркивание через псевдоэлемент**

Можно сделать кастомное подчёркивание:

```css
h2 {
  position: relative;
  display: inline-block;
}

h2::after {
  content: "";
  position: absolute;
  left: 25%;
  bottom: -6px;
  width: 50%;
  height: 3px;
  background-color: #333;
  border-radius: 2px;
}
```

**Когда использовать псевдоэлементы:**

- Для добавления символов, иконок, декоративных элементов  
- Для оформления заголовков, кнопок, карточек  
- Для создания стилистических эффектов без дополнительной разметки  

**Особенности:**

- Псевдоэлементы наследуют стиль родителя, если не указано иначе  
- Их можно позиционировать, анимировать, стилизовать как обычные блоки  
- Поддерживаются всеми современными браузерами  

---

## 4. Каскадность и специфичность

CSS расшифровывается как **Cascading Style Sheets** — каскадные таблицы стилей.  
Если к одному и тому же элементу применяются несколько правил, они могут конфликтовать. В таком случае браузер должен определить, какое правило важнее.  

---

### 4.1. Каскадность

Каскадность — это правило, по которому браузер выбирает, какой стиль применить, если элементу заданы разные стили из разных источников.  

**Источники стилей:**

1. Браузер по умолчанию (`user agent styles`)  
2. Пользовательские стили (`user styles`)  
3. Внешние, внутренние и встроенные CSS от разработчика (`author styles`)  

Если одно и то же свойство задано в нескольких местах, применяется то, которое:  

- идёт ниже по порядку  
- имеет более высокую специфичность  
- имеет директиву `!important` (если есть)  

---

### 4.2. Специфичность

Специфичность — это **вес селектора**. Чем он точнее, тем выше его приоритет.  

Браузер присваивает селекторам "вес", используя условную систему подсчёта:

| Тип селектора            | Вес  | | | |
|--------------------------|------|---|---|---|
| Стили в `style=""`       | 1000 | | | |
| `#id`                    | 100 | | | |
| `.class`, `[attr]`, `:hover` | 10 | | | |
| `element`, `::before`    | 1 | | | |

Чем больше сумма, тем выше приоритет.  

**Пример:**

```html
<style>
p {
  color: black;        /* вес: 1 */
}

.text {
  color: blue;         /* вес: 10 */
}

#main {
  color: red;          /* вес: 100 */
}
</style>

<p id="main" class="text">Пример</p>
```

В этом случае победит стиль с `#main`, потому что у него высшая специфичность (100 против 10 и 1).  

---

### 4.3. !important

Иногда разработчик может принудительно применить стиль, независимо от специфичности:  

```css
p {
  color: green !important;
}
```

Стили с `!important` перекрывают любые другие, кроме других `!important` с более высокой специфичностью.  

Использовать `!important` следует только в крайних случаях — например, при интеграции со сторонними библиотеками или в стилях временного характера.  
Постоянное его применение делает код нечитаемым и трудно поддерживаемым.  

---

## 5. Box Model (Модель коробки)

Каждый HTML-элемент в браузере воспринимается как прямоугольная коробка.  
Понимание **box model** необходимо для управления размерами, отступами и границами элементов.  

---

### 5.1. Состав Box Model

Модель коробки состоит из четырёх уровней (от центра к краям):  

- **content** — содержимое элемента: текст, изображения и т.д.  
  Устанавливается через свойства вроде `width`, `height`  

- **padding** — внутренний отступ: пространство между содержимым и границей  

**Пример:**

```css
padding: 10px;
```

- **border** — рамка вокруг элемента. Задаётся через `border-width`, `border-style`, `border-color`.  

**Пример:**

```css
border: 2px solid black;
```

- **margin** — внешний отступ: расстояние от текущего элемента до других  

**Пример:**

```css
margin: 20px;
```

**Свойства для управления:**

- `padding-top`, `padding-right`, `padding-bottom`, `padding-left`  
- `margin-top`, `margin-right`, `margin-bottom`, `margin-left`  
- `border-width`, `border-style`, `border-color`  

Также можно записывать коротко:  

```css
padding: 10px 20px;     /* сверху/снизу 10px, слева/справа 20px */
margin: 5px 10px 15px 20px; /* сверху, справа, снизу, слева */
```

---

### 5.2. Схема расчёта размеров

По умолчанию:

```css
box-sizing: content-box;
```

Это означает: `width` и `height` задают размеры только для содержимого, и к ним добавляются `padding` и `border`.  

**Пример:**

```css
width: 200px;
padding: 10px;
border: 2px solid;
```

Фактическая ширина элемента: 200 + 10*2 + 2*2 = 224px  

Чтобы включить альтернативный способ расчёта, где `padding` и `border` входят в `width`:

```css
box-sizing: border-box;
```

Это делает вёрстку проще и предсказуемей, особенно при работе с сетками и адаптивным дизайном.  

Обычно это правило применяют ко всей странице:

```css
* {
  box-sizing: border-box;
}
```

---

## 6. Цвета, шрифты и фоны

Оформление текста и фона — основа визуального дизайна интерфейса.  
В этом разделе — базовые CSS-свойства, с помощью которых можно управлять цветами, типографикой и задними фонами элементов.  

---

### 6.1. Цвет текста и фона

Цвет текста задаётся через свойство `color`, а цвет фона — через `background-color`.  

**Пример:**

```css
body {
  color: #222;                /* тёмный текст */
  background-color: #f8f8f8;  /* светлый фон */
}
```

**Форматы задания цвета:**

- Ключевые слова: `red`, `blue`, `black`  
- HEX: `#ff6600`, `#333333`  
- RGB: `rgb(255, 102, 0)`  
- RGBA: `rgba(0, 0, 0, 0.5)` (поддержка прозрачности)  
- HSL/HSLA: `hsl(30, 100%, 50%)`  

---

### 6.2. Шрифты

Основные свойства для управления текстом:  

```css
body {
  font-family: 'Segoe UI', sans-serif;
  font-size: 16px;
  font-weight: 400;
  line-height: 1.5;
  letter-spacing: 0.5px;
}
```

- **font-family** — список шрифтов по приоритету. Последний — запасной (`sans-serif`, `serif`, `monospace`)  
- **font-size** — размер шрифта (в `px`, `em`, `rem` и др.)  
- **font-weight** — насыщенность: `normal`, `bold`, `100–900`  
- **line-height** — межстрочный интервал, удобно задавать без единиц (`1.4`, `1.6`)  
- **letter-spacing** — расстояние между буквами  

**Типичный стек шрифтов:**

```css
font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
```

```css
p {
  text-align: justify;
  text-transform: uppercase;
  text-decoration: underline;
}
```

- **text-align** — выравнивание: `left`, `right`, `center`, `justify`  
- **text-transform** — изменение регистра (`uppercase`, `lowercase`, `capitalize`)  
- **text-decoration** — подчёркивание, зачеркивание, подчёркивание волной  

---

### 6.4. Фоны

Для фона используется свойство `background` или более подробно:  

```css
section {
  background-color: #eee;
  background-image: url('bg.jpg');
  background-repeat: no-repeat;
  background-size: cover;
  background-position: center;
}
```

- **background-color** — цвет фона  
- **background-image** — изображение  
- **background-repeat** — повторение: `repeat`, `no-repeat`  
- **background-size** — размер: `cover`, `contain`, `auto`, конкретные размеры  
- **background-position** — позиционирование: `center`, `top left`, координаты  

---

## 7. Подключение стилей: inline, internal, external

CSS можно подключать к HTML-документу тремя способами, и у каждого есть свои особенности и применимость.  

### 7.1. Inline (встроенные стили)

Стили указываются прямо в атрибуте `style` внутри HTML-тега.  

**Пример:**

```html
<p style="color: red; font-size: 18px;">Привет, мир!</p>
```

**Плюсы:**

- Быстро и просто для разовой стилизации  
- Удобно для тестирования или генерации стилей через JavaScript  

**Минусы:**

- Плохо масштабируется  
- Переполняет HTML-разметку  
- Трудно переопределять и поддерживать  

**Когда использовать:** только для динамической стилизации в JS или при отладке  

---

### 7.2. Internal (внутренние стили)

Стили размещаются в секции `<style>` внутри `<head>` текущей HTML-страницы.  

**Пример:**

```html
<head>
  <style>
    body {
      background-color: #f0f0f0;
      color: #333;
    }
  </style>
</head>
```

**Плюсы:**

- Быстро и удобно для небольших проектов или прототипов  
- Все стили в одном файле  

**Минусы:**

- Нельзя переиспользовать между страницами  
- Загромождает HTML-документ  

**Когда использовать:** в учебных примерах, email-верстке, одностраничных документах  

---

### 7.3. External (внешний файл)

CSS хранится в отдельном `.css` файле и подключается через `<link>`:  

**Пример:**

```html
<head>
  <link rel="stylesheet" href="styles.css">
</head>
```

**Плюсы:**

- Централизованное управление стилями  
- Переиспользуемость на всех страницах сайта  
- Кэширование браузером — быстрее загрузка  

**Минусы:**

- Отдельный HTTP-запрос (хотя это не критично)  
- Сложнее отлаживать без инструментов разработчика  

**Когда использовать:** всегда, если вы работаете над полноценным сайтом или веб-приложением  

---

## 8. Позиционирование элементов в CSS

Свойство `position` управляет положением элемента на странице и его отношением к другим элементам.  

**Значения `position`:**
- **static** — по умолчанию.  
  Элемент следует обычному потоку документа. Свойства `top`, `left` и т.п. не работают.  
  Используется, если позиционирование не нужно.  
- **relative** — относительно самого себя.  
  Элемент остаётся в потоке, но его можно сдвинуть:  

```css
position: relative;
top: 10px;
left: 20px;
```

Часто используется как контейнер для абсолютных вложенных элементов.  

- **absolute** — абсолютное позиционирование.  
  Элемент удаляется из потока и позиционируется относительно ближайшего родителя с `relative`, `absolute`, `fixed` или `sticky` (если такого нет — относительно `body`).  

**Пример:**

```css
.parent {
  position: relative;
}

.child {
  position: absolute;
  top: 0;
  right: 0;
}
```

Используется для: всплывающих окон, иконок, тегов и прочего.  

- **fixed** — фиксированное относительно окна.  
  Элемент фиксируется относительно экрана, не прокручивается при `scroll`.  

**Пример:**

```css
.back-to-top {
  position: fixed;
  bottom: 20px;
  right: 20px;
}
```

Часто используется для кнопок, панелей, уведомлений.  

- **sticky** — "плавающее" поведение.  
  Элемент ведёт себя как `relative`, пока не достигнет определённой точки (`top`, `left` и т.д.), затем становится `fixed`.  

**Пример:**

```css
header {
  position: sticky;
  top: 0;
}
```

Работает только внутри родителя с высотой. Часто используется для шапок и заголовков таблиц.  

**Полезные моменты:**

- Все значения `position`, кроме `static`, работают с `top`, `left`, `right`, `bottom`  
- Элементы с `absolute`, `fixed` и `sticky` могут перекрываться — в таких случаях используется `z-index`  
- Убедитесь, что родитель `relative`, если используете `absolute` внутри  
- `sticky` не работает, если у родителя нет высоты или `overflow: hidden`  

---

## 9. CSS Flexbox

Flexbox (Flexible Box Layout) — это мощная система компоновки, позволяющая легко выравнивать, распределять и управлять элементами в одном измерении: по горизонтали или вертикали.  

Flexbox работает с контейнером и элементами внутри него.  

**Пример:**

```css
.container {
  display: flex;
}
```

Теперь все прямые дети `.container` становятся flex-элементами.  

---

### 9.1. Ось и направление

- **Main axis** (основная ось): по умолчанию — горизонтальная  
- **Cross axis** (перпендикулярная ось): вертикальная  

Можно изменить направление оси:

```css
flex-direction: row | row-reverse | column | column-reverse;
```

---

### 9.2. Свойства flex-контейнера

```css
.container {
  display: flex;
  flex-direction: row;
  justify-content: space-between;
  align-items: center;
  gap: 20px;
}
```
- **justify-content** — выравнивание по main axis: `flex-start`, `center`, `flex-end`, `space-between`, `space-around`, `space-evenly`  
- **align-items** — выравнивание по cross axis: `stretch`, `flex-start`, `center`, `flex-end`, `baseline`  
- **gap** — расстояние между flex-элементами (удобнее, чем `margin`)  

---

### 9.3. Свойства flex-элементов

```css
.item {
  flex-grow: 1;
  flex-shrink: 1;
  flex-basis: 200px;
}
```

Или кратко:  

```css
flex: 1 1 200px;
```

- **flex-grow** — возможность расширяться  
- **flex-shrink** — сжиматься при нехватке места  
- **flex-basis** — базовая ширина/высота (по основной оси)  

Также:  
- **align-self** — переопределяет `align-items` для одного элемента  
- **order** — изменяет порядок отображения  

---

## 10. CSS Grid: двумерная сетка

CSS Grid Layout — это система компоновки, позволяющая размещать элементы по строкам и столбцам одновременно.  
Это делает Grid идеальным инструментом для создания табличных и комплексных макетов.  

---

### 10.1. Свойства Grid-контейнера

Это свойства, которые задаются на родительском элементе, чтобы создать сетку и управлять её структурой.  

```css
.container {
  display: grid;
}
```

**Основные свойства:**

- **display: grid** — включает grid-контекст  
- **grid-template-columns** — задаёт количество и ширину колонок  

**Примеры:**

```css
grid-template-columns: 1fr 1fr 1fr; /* 3 равные колонки */
grid-template-columns: 200px auto 1fr; /* разная ширина */
```

- **grid-template-rows** — аналогично для строк  

**Пример:**

```css
grid-template-rows: auto 1fr auto;
```

- **gap** — расстояние между ячейками:  

**Примеры:**

```css
gap: 16px;
row-gap: 20px;
column-gap: 10px;
```

- **grid-template-areas** — именованные области:  

**Пример:**

```css
grid-template-areas:
  "header header"
  "sidebar main"
  "footer footer";
```

- **justify-items / align-items** — выравнивание содержимого ячеек  
- **justify-content / align-content** — выравнивание всей сетки внутри контейнера  

---

### 10.2. Свойства Grid-элемента

Эти свойства задаются для дочерних элементов, чтобы управлять их положением и размером в сетке.  

**Пример:**

```css
.item {
  grid-column: 1 / 3; /* от линии 1 до 3 */
  grid-row: 2 / 4;
}
```

- **grid-column / grid-row** — явные линии начала и конца  
- **grid-column-start, grid-column-end** — можно указать отдельно  
- **grid-row: span 2** — занять несколько строк  
- **grid-area** — используется с `grid-template-areas`  

**Пример:**

```css
.header {
  grid-area: header;
}
```

- **justify-self / align-self** — выравнивание конкретного элемента в ячейке  

---

## 11. Примеры верстки

Типовые схемы вёрстки, которые часто встречаются на сайтах: шапка, контент, сайдбар, подвал — реализованные с помощью Flexbox и CSS Grid.  

---

### 11.1. Пример макета на Flexbox

```html
<style>
body {
  margin: 0;
  font-family: sans-serif;
}

.header,
.footer {
  background: #3f51b5;
  color: white;
  padding: 20px;
  text-align: center;
}

.main {
  display: flex;
  min-height: 300px;
}

.sidebar {
  background: #f5f5f5;
  width: 250px;
  padding: 20px;
}

.content {
  flex: 1;
  padding: 20px;
}
</style>

<div class="header">Хедер</div>

<div class="main">
  <div class="sidebar">Сайдбар</div>
  <div class="content">Контент</div>
</div>

<div class="footer">Футер</div>
```

---


### 11.2. Пример макета на CSS Grid

```html
<style>
body {
  margin: 0;
  font-family: sans-serif;
}

.grid {
  display: grid;
  grid-template-areas:
    "header header"
    "sidebar content"
    "footer footer";
  grid-template-columns: 200px 1fr;
  grid-template-rows: auto 1fr auto;
  min-height: 100vh;
}

.header {
  grid-area: header;
  background: #673ab7;
  color: white;
  padding: 20px;
  text-align: center;
}

.sidebar {
  grid-area: sidebar;
  background: #ede7f6;
  padding: 20px;
}

.content {
  grid-area: content;
  padding: 20px;
}

.footer {
  grid-area: footer;
  background: #512da8;
  color: white;
  padding: 20px;
  text-align: center;
}
</style>

<div class="grid">
  <div class="header">Хедер</div>
  <div class="sidebar">Сайдбар</div>
  <div class="content">Контент</div>
  <div class="footer">Футер</div>
</div>
```

---


### 11.3. Галерея карточек с адаптивной шириной

```html
<style>
.grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
  gap: 16px;
  padding: 20px;
}

.card {
  background: #ffcc80;
  padding: 20px;
  text-align: center;
}
</style>

<div class="grid">
  <div class="card">Карточка 1</div>
  <div class="card">Карточка 2</div>
  <div class="card">Карточка 3</div>
  <div class="card">Карточка 4</div>
</div>
```
